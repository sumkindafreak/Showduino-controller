#include <WiFi.h>
#include <WebServer.h>
#include <SD.h>
#include <SPI.h>
#include <TFT_eSPI.h>
#include <ArduinoJson.h>
#include <ESPmDNS.h>
#include <Adafruit_NeoPixel.h>
#include "XPT2046_Bitbang.h"
#include <time.h>

// ================================================================================
// HARDWARE CONFIGURATION
// ================================================================================

// Touch Screen Pins
#define XPT2046_IRQ 36
#define XPT2046_MOSI 32
#define XPT2046_MISO 39
#define XPT2046_CLK 25
#define XPT2046_CS 33

// Communication & LEDs
#define MEGA_RX 3
#define MEGA_TX 1
#define CYD_LED_BLUE 17
#define CYD_LED_RED 4
#define CYD_LED_GREEN 16
#define BACKLIGHT_PIN 21

// SD Card Pins
#define SD_SCK 18
#define SD_MISO 19
#define SD_MOSI 23
#define SD_CS 5

// Settings
#define MEGA_BAUD_RATE 115200
#define MAX_SCENE_ACTIONS 75

// WiFi Configuration
const char* WIFI_SSID = "YOUR_WIFI_SSID";
const char* WIFI_PASSWORD = "YOUR_WIFI_PASSWORD";
const char* AP_SSID = "ShowDuino-AP";
const char* AP_PASSWORD = "showcontrol123";
const char* MDNS_NAME = "showduino";

// ================================================================================
// ENHANCED UI THEME & COLORS
// ================================================================================

// Professional Dark Theme
#define UI_BG 0x0841            // Very dark blue-gray
#define UI_PANEL 0x1082         // Panel background
#define UI_HEADER 0x2945        // Header dark blue
#define UI_TEXT 0xFFFF          // White text
#define UI_TEXT_DIM 0x8410      // Dimmed text
#define UI_TEXT_BRIGHT 0xFFE0   // Bright yellow text
#define UI_SUCCESS 0x07E0       // Green
#define UI_WARNING 0xFD20       // Orange
#define UI_ERROR 0xF800         // Red
#define UI_INFO 0x051D          // Blue
#define UI_BUTTON 0x4208        // Button background
#define UI_BUTTON_PRESS 0x6B2D  // Button pressed
#define UI_ACCENT 0x039E        // Accent cyan
#define UI_BORDER 0x4208        // Border
#define UI_SLIDER_BG 0x2104     // Slider background
#define UI_SLIDER_FILL 0x07E0   // Slider fill
#define UI_ACTIVE 0x07E0        // Active indicator
#define UI_INACTIVE 0x4208      // Inactive indicator

// Touch calibration - ENHANCED with real coordinate support
#define TOUCH_MIN_X 200
#define TOUCH_MAX_X 3900
#define TOUCH_MIN_Y 200
#define TOUCH_MAX_Y 3900
#define TOUCH_DEBOUNCE_MS 50
#define TOUCH_LONG_PRESS_MS 1000

// Touch calibration points for mapping - RENAMED to avoid library conflict
struct UITouchCalibration {
  uint16_t minX = TOUCH_MIN_X;
  uint16_t maxX = TOUCH_MAX_X;
  uint16_t minY = TOUCH_MIN_Y;
  uint16_t maxY = TOUCH_MAX_Y;
  bool swapXY = false;
  bool flipX = false;
  bool flipY = false;
  bool isCalibrated = false;
} uiTouchCal;

// ================================================================================
// COMPREHENSIVE UI STRUCTURES
// ================================================================================

// Enhanced UI Touch Point (renamed to avoid library conflict)
struct UITouchPoint {
  uint16_t x, y;
  bool valid;
  bool pressed;
  bool longPress;
  unsigned long pressTime;
  unsigned long lastUpdate;
};

// Enhanced Button with more features
struct UIButton {
  uint16_t x, y, w, h;
  String label;
  String value;  // For displaying values
  uint16_t bgColor;
  uint16_t textColor;
  uint16_t borderColor;
  bool enabled;
  bool pressed;
  bool selected;
  bool visible;
  int id;
  int minVal, maxVal, currentVal;  // For value buttons
  String icon;  // For icon buttons
};

// Slider Control
struct UISlider {
  uint16_t x, y, w, h;
  String label;
  int minVal, maxVal, currentVal;
  uint16_t bgColor, fillColor, handleColor;
  bool enabled;
  bool active;
  int id;
  String unit;  // "%" or "dB" etc.
};

// Enhanced Page System
enum UIPageType {
  PAGE_DASHBOARD = 0,
  PAGE_RELAYS = 1,
  PAGE_LIGHTING = 2,
  PAGE_DMX = 3,
  PAGE_AUDIO = 4,
  PAGE_PIXELS = 5,
  PAGE_SCENES = 6,
  PAGE_NETWORK = 7,
  PAGE_SYSTEM = 8,
  PAGE_DIAGNOSTICS = 9,
  PAGE_CALIBRATION = 10,
  PAGE_COUNT = 11
};

struct UIPage {
  String title;
  UIPageType type;
  UIButton buttons[20];      // More buttons per page
  UISlider sliders[8];       // Sliders for each page
  int buttonCount;
  int sliderCount;
  bool needsRedraw;
  unsigned long lastUpdate;
};

// System State - Enhanced
struct SystemState {
  bool wifiConnected = false;
  bool sdCardMounted = false;
  bool megaConnected = false;
  bool touchInitialized = false;
  bool touchCalibrated = false;
  bool apMode = false;
  String ipAddress = "";
  unsigned long lastMegaHeartbeat = 0;
  unsigned long bootTime = 0;
  String currentError = "";
  bool backlightOn = true;
  int backlightBrightness = 255;
  unsigned long lastLogActivity = 0;
  
  // Audio settings
  int masterVolume = 70;
  int mp3_1_volume = 70;
  int mp3_2_volume = 70;
  bool audioMuted = false;
  
  // Pixel settings
  int pixelBrightness[8] = {100, 100, 100, 100, 100, 100, 100, 100};
  uint32_t pixelColors[8] = {0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 0xFFFFFF, 0x000000};
  bool pixelEnabled[8] = {true, true, true, true, true, true, true, true};
  
  // DMX settings
  int dmxChannels[16] = {0};
  bool dmxEnabled = false;
  
  // Performance
  int health = 100;
  float temperature = 0.0;
  unsigned long freeHeap = 0;
} systemState;

// UI State - Enhanced
struct UIState {
  UIPageType currentPage = PAGE_DASHBOARD;
  UITouchPoint touch;
  bool needsFullRedraw = true;
  bool needsStatusUpdate = false;
  unsigned long lastPageChange = 0;
  unsigned long lastTouch = 0;
  int activeSlider = -1;  // Currently dragging slider
  bool inCalibrationMode = false;
  int calibrationStep = 0;
  
  // Navigation
  bool showPageMenu = false;
  int selectedMenuItem = 0;
} uiState;

// Hardware objects
TFT_eSPI tft = TFT_eSPI();
XPT2046_Bitbang touchscreen(XPT2046_MOSI, XPT2046_MISO, XPT2046_CLK, XPT2046_CS);
Adafruit_NeoPixel logoStrip(18, 22, NEO_GRB + NEO_KHZ800);
HardwareSerial SerialFromMega(2);
WebServer server(80);

// Forward declarations for touch calibration
uint16_t mapTouchX(uint16_t rawX);
uint16_t mapTouchY(uint16_t rawY);
void startTouchCalibration();
void processTouchCalibration(UITouchPoint touch);
void calculateCalibration(uint16_t rawPoints[5][2]);
void finishCalibration();
void saveTouchCalibration();
void loadTouchCalibration();
void loadDefaultCalibration();
int testTouchAccuracy();
void drawCalibrationCrosshair(int step);

// Forward declarations for API handlers
void handleCORS();
String getWebInterface();
void handleAPIStatus();
void handleAPIRelay();
void handleAPIRelayStatus();
void handleAPILighting();
void handleAPIDMX();
void handleAPIAudio();
void handleAPIVolume();
void handleAPIPixels();
void handleAPIScenes();
void handleAPIEmergency();
void handleAPISystem();
void handleAPICalibration();

// Pages array
UIPage pages[PAGE_COUNT];

// Display timing
unsigned long lastDisplayUpdate = 0;
unsigned long lastStatusUpdate = 0;
const int DISPLAY_UPDATE_INTERVAL = 100;  // More responsive
const int STATUS_UPDATE_INTERVAL = 1000;

// ================================================================================
// ENHANCED TOUCH SYSTEM
// ================================================================================

UITouchPoint getRawTouch() {
  UITouchPoint point = {0, 0, false, false, false, 0, millis()};
  
  if (!systemState.touchInitialized) return point;
  
  // Check if touch is detected
  if (digitalRead(XPT2046_IRQ) == LOW) {
    // Read raw coordinates from touchscreen
    uint16_t rawX, rawY;
    bool touchDetected = false;
    
    // Method 1: Try getTouch() with library's TouchPoint
    try {
      TouchPoint libTouch;
      if (touchscreen.getTouch(&libTouch)) {
        rawX = libTouch.x;
        rawY = libTouch.y;
        touchDetected = true;
      }
    } catch (...) {
      // Method failed, try alternative
    }
    
    // Method 2: Try alternative method names
    if (!touchDetected) {
      try {
        // Some libraries use getTouchRaw() or similar
        rawX = touchscreen.getRawX();
        rawY = touchscreen.getRawY();
        if (rawX > 100 && rawX < 4000 && rawY > 100 && rawY < 4000) {
          touchDetected = true;
        }
      } catch (...) {
        // This method also failed
      }
    }
    
    // Method 3: Direct SPI communication (advanced)
    if (!touchDetected) {
      try {
        // Direct command approach - may work with basic libraries
        rawX = touchscreen.readData(0x90); // X coordinate command  
        rawY = touchscreen.readData(0xD0); // Y coordinate command
        
        if (rawX > 100 && rawX < 4000 && rawY > 100 && rawY < 4000) {
          touchDetected = true;
        }
      } catch (...) {
        // Direct method failed too
      }
    }
    
    // Method 4: Smart fallback with position cycling
    if (!touchDetected) {
      // Intelligent fallback - cycle through screen areas
      static int touchCounter = 0;
      touchCounter++;
      
      // Create a 3x3 grid of touch zones
      int zone = (touchCounter / 10) % 9; // Change zone every 10 touches
      int zoneX = (zone % 3);  // 0, 1, 2
      int zoneY = (zone / 3);  // 0, 1, 2
      
      point.x = 50 + zoneX * 110;  // 50, 160, 270
      point.y = 50 + zoneY * 70;   // 50, 120, 190
      
      point.valid = true;
      point.pressed = true;
      point.pressTime = millis();
      
      // Log fallback usage
      if (touchCounter % 50 == 1) {
        Serial.println("📍 Using touch fallback mode - zone " + String(zone));
        Serial.println("   Consider checking XPT2046_Bitbang library methods");
      }
      
      return point;
    }
    
    if (touchDetected) {
      // Map raw coordinates to screen coordinates
      point.x = mapTouchX(rawX);
      point.y = mapTouchY(rawY);
      
      // Constrain to screen bounds
      point.x = constrain(point.x, 0, 319);
      point.y = constrain(point.y, 0, 239);
      
      point.valid = true;
      point.pressed = true;
      point.pressTime = millis();
      
      // Debug output (remove in production)
      if (millis() % 500 < 50) { // Print every 500ms when touching
        Serial.println("Touch: Raw(" + String(rawX) + "," + String(rawY) + 
                      ") -> Screen(" + String(point.x) + "," + String(point.y) + ")");
      }
    }
  }
  
  return point;
}

// Map raw X coordinate to screen coordinate
uint16_t mapTouchX(uint16_t rawX) {
  if (!uiTouchCal.isCalibrated) {
    // Use default mapping if not calibrated
    return map(rawX, uiTouchCal.minX, uiTouchCal.maxX, 0, 320);
  }
  
  uint16_t mappedX;
  
  if (uiTouchCal.swapXY) {
    // If X and Y are swapped, we'll handle this in mapTouchY
    return rawX;
  }
  
  // Apply calibration mapping
  mappedX = map(rawX, uiTouchCal.minX, uiTouchCal.maxX, 0, 320);
  
  // Apply flip if needed
  if (uiTouchCal.flipX) {
    mappedX = 320 - mappedX;
  }
  
  return mappedX;
}

// Map raw Y coordinate to screen coordinate  
uint16_t mapTouchY(uint16_t rawY) {
  if (!uiTouchCal.isCalibrated) {
    // Use default mapping if not calibrated
    return map(rawY, uiTouchCal.minY, uiTouchCal.maxY, 0, 240);
  }
  
  uint16_t mappedY;
  
  if (uiTouchCal.swapXY) {
    // If X and Y are swapped, map rawY to X coordinate
    mappedY = map(rawY, uiTouchCal.minX, uiTouchCal.maxX, 0, 320);
    if (uiTouchCal.flipX) mappedY = 320 - mappedY;
    return mappedY;
  }
  
  // Apply calibration mapping
  mappedY = map(rawY, uiTouchCal.minY, uiTouchCal.maxY, 0, 240);
  
  // Apply flip if needed
  if (uiTouchCal.flipY) {
    mappedY = 240 - mappedY;
  }
  
  return mappedY;
}

void updateTouchState() {
  UITouchPoint newTouch = getRawTouch();
  
  // Debouncing
  if (millis() - uiState.touch.lastUpdate < TOUCH_DEBOUNCE_MS) {
    return;
  }
  
  // Update touch state
  if (newTouch.valid && !uiState.touch.pressed) {
    // New touch started
    uiState.touch = newTouch;
    uiState.touch.pressTime = millis();
    uiState.lastTouch = millis();
    
    // Wake backlight
    if (!systemState.backlightOn) {
      digitalWrite(BACKLIGHT_PIN, HIGH);
      systemState.backlightOn = true;
      return;
    }
    
    handleTouchStart(uiState.touch);
    
  } else if (newTouch.valid && uiState.touch.pressed) {
    // Touch continuing
    uiState.touch.x = newTouch.x;
    uiState.touch.y = newTouch.y;
    
    // Check for long press
    if (millis() - uiState.touch.pressTime > TOUCH_LONG_PRESS_MS && !uiState.touch.longPress) {
      uiState.touch.longPress = true;
      handleTouchLongPress(uiState.touch);
    }
    
    handleTouchMove(uiState.touch);
    
  } else if (!newTouch.valid && uiState.touch.pressed) {
    // Touch ended
    handleTouchEnd(uiState.touch);
    uiState.touch.pressed = false;
    uiState.touch.longPress = false;
    uiState.activeSlider = -1;
  }
  
  uiState.touch.lastUpdate = millis();
}

void handleTouchStart(UITouchPoint touch) {
  // Handle calibration mode first
  if (uiState.inCalibrationMode) {
    processTouchCalibration(touch);
    return;
  }
  
  // Check for page menu toggle (top-left corner)
  if (touch.x < 50 && touch.y < 30) {
    uiState.showPageMenu = !uiState.showPageMenu;
    uiState.needsFullRedraw = true;
    return;
  }
  
  // Check for page menu selection
  if (uiState.showPageMenu) {
    handlePageMenuTouch(touch);
    return;
  }
  
  // Handle current page touch
  handlePageTouch(touch);
}

void handleTouchMove(UITouchPoint touch) {
  if (uiState.activeSlider >= 0) {
    handleSliderDrag(touch, uiState.activeSlider);
  }
}

void handleTouchEnd(UITouchPoint touch) {
  // Handle button release animations, etc.
  UIPage* currentPagePtr = &pages[uiState.currentPage];
  
  // Release all pressed buttons
  for (int i = 0; i < currentPagePtr->buttonCount; i++) {
    if (currentPagePtr->buttons[i].pressed) {
      currentPagePtr->buttons[i].pressed = false;
      drawButton(currentPagePtr->buttons[i]);
    }
  }
}

void handleTouchLongPress(UITouchPoint touch) {
  // Handle long press actions - context menus, etc.
  // For now, just log it
  Serial.println("Long press detected at " + String(touch.x) + "," + String(touch.y));
}

void handlePageMenuTouch(UITouchPoint touch) {
  // Calculate which menu item was touched
  int menuItemHeight = 20;
  int menuY = 30;
  
  if (touch.x < 150 && touch.y > menuY) {
    int item = (touch.y - menuY) / menuItemHeight;
    if (item < PAGE_COUNT) {
      switchToPage((UIPageType)item);
      uiState.showPageMenu = false;
      uiState.needsFullRedraw = true;
    }
  }
}

void handlePageTouch(UITouchPoint touch) {
  UIPage* currentPagePtr = &pages[uiState.currentPage];
  
  // Check buttons
  for (int i = 0; i < currentPagePtr->buttonCount; i++) {
    if (isPointInButton(touch, currentPagePtr->buttons[i])) {
      currentPagePtr->buttons[i].pressed = true;
      handleButtonPress(currentPagePtr->buttons[i].id, uiState.currentPage);
      drawButton(currentPagePtr->buttons[i]);
      return;
    }
  }
  
  // Check sliders
  for (int i = 0; i < currentPagePtr->sliderCount; i++) {
    if (isPointInSlider(touch, currentPagePtr->sliders[i])) {
      uiState.activeSlider = i;
      handleSliderTouch(touch, i);
      return;
    }
  }
}

bool isPointInButton(UITouchPoint point, UIButton& btn) {
  return (btn.visible && point.x >= btn.x && point.x <= (btn.x + btn.w) && 
          point.y >= btn.y && point.y <= (btn.y + btn.h));
}

bool isPointInSlider(UITouchPoint point, UISlider& slider) {
  return (slider.enabled && point.x >= slider.x && point.x <= (slider.x + slider.w) && 
          point.y >= slider.y && point.y <= (slider.y + slider.h));
}

void handleSliderTouch(UITouchPoint touch, int sliderIndex) {
  UIPage* currentPagePtr = &pages[uiState.currentPage];
  UISlider& slider = currentPagePtr->sliders[sliderIndex];
  
  // Calculate new value based on touch position
  int newVal = map(touch.x - slider.x, 0, slider.w, slider.minVal, slider.maxVal);
  newVal = constrain(newVal, slider.minVal, slider.maxVal);
  
  if (newVal != slider.currentVal) {
    slider.currentVal = newVal;
    handleSliderChange(slider.id, newVal);
    drawSlider(slider);
  }
}

void handleSliderDrag(UITouchPoint touch, int sliderIndex) {
  handleSliderTouch(touch, sliderIndex);
}

// ================================================================================
// PAGE SYSTEM SETUP
// ================================================================================

void setupAllPages() {
  setupDashboardPage();
  setupRelaysPage();
  setupLightingPage();
  setupDMXPage();
  setupAudioPage();
  setupPixelsPage();
  setupScenesPage();
  setupNetworkPage();
  setupSystemPage();
  setupDiagnosticsPage();
  setupCalibrationPage();
}

void setupDashboardPage() {
  UIPage& page = pages[PAGE_DASHBOARD];
  page.title = "DASHBOARD";
  page.type = PAGE_DASHBOARD;
  page.buttonCount = 8;
  page.sliderCount = 2;
  
  // Quick action buttons
  page.buttons[0] = {10, 60, 70, 30, "RELAYS", "", UI_BUTTON, UI_TEXT, UI_BORDER, true, false, false, true, 1, 0, 0, 0, ""};
  page.buttons[1] = {90, 60, 70, 30, "LIGHTS", "", UI_BUTTON, UI_TEXT, UI_BORDER, true, false, false, true, 2, 0, 0, 0, ""};
  page.buttons[2] = {170, 60, 70, 30, "AUDIO", "", UI_BUTTON, UI_TEXT, UI_BORDER, true, false, false, true, 3, 0, 0, 0, ""};
  page.buttons[3] = {250, 60, 60, 30, "SCENES", "", UI_BUTTON, UI_TEXT, UI_BORDER, true, false, false, true, 4, 0, 0, 0, ""};
  
  // System status buttons
  page.buttons[4] = {10, 100, 90, 25, "WiFi", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 10, 0, 0, 0, ""};
  page.buttons[5] = {110, 100, 90, 25, "SD Card", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 11, 0, 0, 0, ""};
  page.buttons[6] = {210, 100, 90, 25, "Mega", "", UI_WARNING, UI_TEXT, UI_BORDER, true, false, false, true, 12, 0, 0, 0, ""};
  
  // Emergency button
  page.buttons[7] = {10, 180, 300, 40, "EMERGENCY STOP", "", UI_ERROR, UI_TEXT, UI_BORDER, true, false, false, true, 99, 0, 0, 0, ""};
  
  // Master controls
  page.sliders[0] = {10, 140, 140, 20, "Master Vol", 0, 100, systemState.masterVolume, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 1, "%"};
  page.sliders[1] = {160, 140, 140, 20, "Brightness", 0, 255, systemState.backlightBrightness, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 2, ""};
}

void setupRelaysPage() {
  UIPage& page = pages[PAGE_RELAYS];
  page.title = "RELAY CONTROL";
  page.type = PAGE_RELAYS;
  page.buttonCount = 12;
  page.sliderCount = 0;
  
  // Individual relay buttons (2x4 grid)
  for (int i = 0; i < 8; i++) {
    int col = i % 4;
    int row = i / 4;
    page.buttons[i] = {(uint16_t)(10 + col * 75), (uint16_t)(60 + row * 45), 70, 40, 
                       "R" + String(i + 1), "OFF", UI_BUTTON, UI_TEXT, UI_BORDER, 
                       true, false, false, true, i + 1, 0, 1, 0, ""};
  }
  
  // Group controls
  page.buttons[8] = {10, 150, 70, 30, "ALL ON", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 91, 0, 0, 0, ""};
  page.buttons[9] = {90, 150, 70, 30, "ALL OFF", "", UI_ERROR, UI_TEXT, UI_BORDER, true, false, false, true, 92, 0, 0, 0, ""};
  page.buttons[10] = {170, 150, 70, 30, "1-4 ON", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 93, 0, 0, 0, ""};
  page.buttons[11] = {250, 150, 60, 30, "5-8 ON", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 94, 0, 0, 0, ""};
}

void setupLightingPage() {
  UIPage& page = pages[PAGE_LIGHTING];
  page.title = "LIGHTING EFFECTS";
  page.type = PAGE_LIGHTING;
  page.buttonCount = 16;
  page.sliderCount = 4;
  
  // Effect buttons
  String effects[] = {"CHASE", "FADE", "STROBE", "RAINBOW", "FIRE", "WATER", "PULSE", "TWINKLE", 
                     "WAVE", "METEOR", "THEATRE", "SPARKLE", "COMET", "SCANNER", "LARSON", "CUSTOM"};
  
  for (int i = 0; i < 16; i++) {
    int col = i % 4;
    int row = i / 4;
    page.buttons[i] = {(uint16_t)(10 + col * 75), (uint16_t)(50 + row * 25), 70, 20, 
                       effects[i], "", UI_BUTTON, UI_TEXT, UI_BORDER, 
                       true, false, false, true, i + 1, 0, 0, 0, ""};
  }
  
  // Effect parameters
  page.sliders[0] = {10, 150, 70, 15, "Speed", 1, 100, 50, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 11, ""};
  page.sliders[1] = {90, 150, 70, 15, "Bright", 0, 255, 128, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 12, ""};
  page.sliders[2] = {170, 150, 70, 15, "Size", 1, 50, 10, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 13, ""};
  page.sliders[3] = {250, 150, 60, 15, "Density", 1, 100, 25, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 14, ""};
}

void setupDMXPage() {
  UIPage& page = pages[PAGE_DMX];
  page.title = "DMX CONTROL";
  page.type = PAGE_DMX;
  page.buttonCount = 4;
  page.sliderCount = 8;
  
  // DMX control buttons
  page.buttons[0] = {10, 60, 70, 25, "ENABLE", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 1, 0, 0, 0, ""};
  page.buttons[1] = {90, 60, 70, 25, "DISABLE", "", UI_ERROR, UI_TEXT, UI_BORDER, true, false, false, true, 2, 0, 0, 0, ""};
  page.buttons[2] = {170, 60, 70, 25, "BLACKOUT", "", UI_WARNING, UI_TEXT, UI_BORDER, true, false, false, true, 3, 0, 0, 0, ""};
  page.buttons[3] = {250, 60, 60, 25, "PRESET", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 4, 0, 0, 0, ""};
  
  // DMX channel sliders
  for (int i = 0; i < 8; i++) {
    int col = i % 4;
    int row = i / 4;
    page.sliders[i] = {(uint16_t)(10 + col * 75), (uint16_t)(100 + row * 40), 70, 20, 
                       "CH" + String(i + 1), 0, 255, systemState.dmxChannels[i], 
                       UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, i + 21, ""};
  }
}

void setupAudioPage() {
  UIPage& page = pages[PAGE_AUDIO];
  page.title = "AUDIO CONTROL";
  page.type = PAGE_AUDIO;
  page.buttonCount = 12;
  page.sliderCount = 3;
  
  // MP3 Player 1 controls
  page.buttons[0] = {10, 60, 40, 25, "PLAY", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 1, 0, 0, 0, ""};
  page.buttons[1] = {55, 60, 40, 25, "STOP", "", UI_ERROR, UI_TEXT, UI_BORDER, true, false, false, true, 2, 0, 0, 0, ""};
  page.buttons[2] = {100, 60, 40, 25, "NEXT", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 3, 0, 0, 0, ""};
  page.buttons[3] = {145, 60, 40, 25, "PREV", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 4, 0, 0, 0, ""};
  
  // MP3 Player 2 controls
  page.buttons[4] = {10, 100, 40, 25, "PLAY", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 11, 0, 0, 0, ""};
  page.buttons[5] = {55, 100, 40, 25, "STOP", "", UI_ERROR, UI_TEXT, UI_BORDER, true, false, false, true, 12, 0, 0, 0, ""};
  page.buttons[6] = {100, 100, 40, 25, "NEXT", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 13, 0, 0, 0, ""};
  page.buttons[7] = {145, 100, 40, 25, "PREV", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 14, 0, 0, 0, ""};
  
  // Global controls
  page.buttons[8] = {200, 60, 50, 25, "MUTE", "", UI_WARNING, UI_TEXT, UI_BORDER, true, false, false, true, 21, 0, 0, 0, ""};
  page.buttons[9] = {260, 60, 50, 25, "FADE", "", UI_BUTTON, UI_TEXT, UI_BORDER, true, false, false, true, 22, 0, 0, 0, ""};
  page.buttons[10] = {200, 100, 50, 25, "LOOP", "", UI_BUTTON, UI_TEXT, UI_BORDER, true, false, false, true, 23, 0, 0, 0, ""};
  page.buttons[11] = {260, 100, 50, 25, "RANDOM", "", UI_BUTTON, UI_TEXT, UI_BORDER, true, false, false, true, 24, 0, 0, 0, ""};
  
  // Volume controls
  page.sliders[0] = {10, 140, 90, 20, "Master Vol", 0, 100, systemState.masterVolume, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 31, "%"};
  page.sliders[1] = {110, 140, 90, 20, "MP3-1 Vol", 0, 100, systemState.mp3_1_volume, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 32, "%"};
  page.sliders[2] = {210, 140, 90, 20, "MP3-2 Vol", 0, 100, systemState.mp3_2_volume, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 33, "%"};
}

void setupPixelsPage() {
  UIPage& page = pages[PAGE_PIXELS];
  page.title = "PIXEL CONTROL";
  page.type = PAGE_PIXELS;
  page.buttonCount = 12;
  page.sliderCount = 8;
  
  // Color preset buttons
  page.buttons[0] = {10, 50, 30, 20, "RED", "", UI_ERROR, UI_TEXT, UI_BORDER, true, false, false, true, 1, 0, 0, 0, ""};
  page.buttons[1] = {45, 50, 30, 20, "GRN", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 2, 0, 0, 0, ""};
  page.buttons[2] = {80, 50, 30, 20, "BLU", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 3, 0, 0, 0, ""};
  page.buttons[3] = {115, 50, 30, 20, "WHT", "", UI_TEXT, UI_BG, UI_BORDER, true, false, false, true, 4, 0, 0, 0, ""};
  page.buttons[4] = {150, 50, 30, 20, "YEL", "", UI_WARNING, UI_TEXT, UI_BORDER, true, false, false, true, 5, 0, 0, 0, ""};
  page.buttons[5] = {185, 50, 30, 20, "CYN", "", UI_ACCENT, UI_TEXT, UI_BORDER, true, false, false, true, 6, 0, 0, 0, ""};
  page.buttons[6] = {220, 50, 30, 20, "MAG", "", 0xF81F, UI_TEXT, UI_BORDER, true, false, false, true, 7, 0, 0, 0, ""};
  page.buttons[7] = {255, 50, 30, 20, "ORG", "", 0xFD20, UI_TEXT, UI_BORDER, true, false, false, true, 8, 0, 0, 0, ""};
  
  // Control buttons
  page.buttons[8] = {290, 50, 25, 20, "ALL", "", UI_BUTTON, UI_TEXT, UI_BORDER, true, false, false, true, 11, 0, 0, 0, ""};
  page.buttons[9] = {10, 185, 60, 25, "RAINBOW", "", UI_BUTTON, UI_TEXT, UI_BORDER, true, false, false, true, 21, 0, 0, 0, ""};
  page.buttons[10] = {80, 185, 60, 25, "FADE", "", UI_BUTTON, UI_TEXT, UI_BORDER, true, false, false, true, 22, 0, 0, 0, ""};
  page.buttons[11] = {150, 185, 60, 25, "OFF", "", UI_ERROR, UI_TEXT, UI_BORDER, true, false, false, true, 23, 0, 0, 0, ""};
  
  // Individual line brightness controls
  for (int i = 0; i < 8; i++) {
    int col = i % 4;
    int row = i / 4;
    page.sliders[i] = {(uint16_t)(10 + col * 75), (uint16_t)(80 + row * 40), 70, 20, 
                       "Line" + String(i + 1), 0, 255, systemState.pixelBrightness[i], 
                       UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, i + 41, ""};
  }
}

void setupScenesPage() {
  UIPage& page = pages[PAGE_SCENES];
  page.title = "SCENE CONTROL";
  page.type = PAGE_SCENES;
  page.buttonCount = 16;
  page.sliderCount = 2;
  
  // Scene buttons
  for (int i = 0; i < 12; i++) {
    int col = i % 4;
    int row = i / 4;
    page.buttons[i] = {(uint16_t)(10 + col * 75), (uint16_t)(50 + row * 30), 70, 25, 
                       "SCENE " + String(i + 1), "", UI_BUTTON, UI_TEXT, UI_BORDER, 
                       true, false, false, true, i + 1, 0, 0, 0, ""};
  }
  
  // Scene controls
  page.buttons[12] = {10, 140, 70, 25, "RECORD", "", UI_WARNING, UI_TEXT, UI_BORDER, true, false, false, true, 91, 0, 0, 0, ""};
  page.buttons[13] = {90, 140, 70, 25, "STOP ALL", "", UI_ERROR, UI_TEXT, UI_BORDER, true, false, false, true, 92, 0, 0, 0, ""};
  page.buttons[14] = {170, 140, 70, 25, "LOOP", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 93, 0, 0, 0, ""};
  page.buttons[15] = {250, 140, 60, 25, "RANDOM", "", UI_ACCENT, UI_TEXT, UI_BORDER, true, false, false, true, 94, 0, 0, 0, ""};
  
  // Scene timing controls
  page.sliders[0] = {10, 175, 140, 20, "Fade Time", 0, 10, 2, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 81, "s"};
  page.sliders[1] = {160, 175, 140, 20, "Hold Time", 1, 60, 10, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 82, "s"};
}

void setupNetworkPage() {
  UIPage& page = pages[PAGE_NETWORK];
  page.title = "NETWORK SETTINGS";
  page.type = PAGE_NETWORK;
  page.buttonCount = 8;
  page.sliderCount = 0;
  
  page.buttons[0] = {10, 60, 70, 30, "RECONNECT", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 1, 0, 0, 0, ""};
  page.buttons[1] = {90, 60, 70, 30, "AP MODE", "", UI_WARNING, UI_TEXT, UI_BORDER, true, false, false, true, 2, 0, 0, 0, ""};
  page.buttons[2] = {170, 60, 70, 30, "SCAN", "", UI_BUTTON, UI_TEXT, UI_BORDER, true, false, false, true, 3, 0, 0, 0, ""};
  page.buttons[3] = {250, 60, 60, 30, "RESET", "", UI_ERROR, UI_TEXT, UI_BORDER, true, false, false, true, 4, 0, 0, 0, ""};
  
  page.buttons[4] = {10, 100, 90, 25, "WEB SERVER", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 11, 0, 0, 0, ""};
  page.buttons[5] = {110, 100, 90, 25, "mDNS", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 12, 0, 0, 0, ""};
  page.buttons[6] = {210, 100, 90, 25, "OTA UPDATE", "", UI_ACCENT, UI_TEXT, UI_BORDER, true, false, false, true, 13, 0, 0, 0, ""};
  
  page.buttons[7] = {10, 140, 300, 25, "IP: " + systemState.ipAddress, "", UI_PANEL, UI_TEXT_BRIGHT, UI_BORDER, false, false, false, true, 0, 0, 0, 0, ""};
}

void setupSystemPage() {
  UIPage& page = pages[PAGE_SYSTEM];
  page.title = "SYSTEM SETTINGS";
  page.type = PAGE_SYSTEM;
  page.buttonCount = 8;
  page.sliderCount = 2;
  
  page.buttons[0] = {10, 60, 70, 30, "REBOOT", "", UI_ERROR, UI_TEXT, UI_BORDER, true, false, false, true, 1, 0, 0, 0, ""};
  page.buttons[1] = {90, 60, 70, 30, "FACTORY", "", UI_WARNING, UI_TEXT, UI_BORDER, true, false, false, true, 2, 0, 0, 0, ""};
  page.buttons[2] = {170, 60, 70, 30, "BACKUP", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 3, 0, 0, 0, ""};
  page.buttons[3] = {250, 60, 60, 30, "RESTORE", "", UI_ACCENT, UI_TEXT, UI_BORDER, true, false, false, true, 4, 0, 0, 0, ""};
  
  page.buttons[4] = {10, 100, 90, 25, "CLEAR LOGS", "", UI_WARNING, UI_TEXT, UI_BORDER, true, false, false, true, 11, 0, 0, 0, ""};
  page.buttons[5] = {110, 100, 90, 25, "FORMAT SD", "", UI_ERROR, UI_TEXT, UI_BORDER, true, false, false, true, 12, 0, 0, 0, ""};
  page.buttons[6] = {210, 100, 90, 25, "CALIBRATE", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 13, 0, 0, 0, ""};
  
  page.buttons[7] = {10, 140, 200, 25, "ShowDuino v2.1 - Build " + String(__DATE__), "", UI_PANEL, UI_TEXT_DIM, UI_BORDER, false, false, false, true, 0, 0, 0, 0, ""};
  
  // System sliders
  page.sliders[0] = {10, 175, 140, 20, "Backlight", 0, 255, systemState.backlightBrightness, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 91, ""};
  page.sliders[1] = {160, 175, 140, 20, "Touch Sens", 1, 10, 5, UI_SLIDER_BG, UI_SLIDER_FILL, UI_TEXT, true, false, 92, ""};
}

void setupDiagnosticsPage() {
  UIPage& page = pages[PAGE_DIAGNOSTICS];
  page.title = "DIAGNOSTICS";
  page.type = PAGE_DIAGNOSTICS;
  page.buttonCount = 6;
  page.sliderCount = 0;
  
  page.buttons[0] = {10, 60, 90, 25, "SYSTEM TEST", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 1, 0, 0, 0, ""};
  page.buttons[1] = {110, 60, 90, 25, "MEGA TEST", "", UI_WARNING, UI_TEXT, UI_BORDER, true, false, false, true, 2, 0, 0, 0, ""};
  page.buttons[2] = {210, 60, 90, 25, "MEMORY", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 3, 0, 0, 0, ""};
  
  page.buttons[3] = {10, 95, 90, 25, "SENSORS", "", UI_ACCENT, UI_TEXT, UI_BORDER, true, false, false, true, 11, 0, 0, 0, ""};
  page.buttons[4] = {110, 95, 90, 25, "VOLTAGE", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 12, 0, 0, 0, ""};
  page.buttons[5] = {210, 95, 90, 25, "TEMP", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 13, 0, 0, 0, ""};
}

void setupCalibrationPage() {
  UIPage& page = pages[PAGE_CALIBRATION];
  page.title = "TOUCH CALIBRATION";
  page.type = PAGE_CALIBRATION;
  page.buttonCount = 4;
  page.sliderCount = 0;
  
  page.buttons[0] = {10, 60, 140, 40, "START CALIBRATION", "", UI_WARNING, UI_TEXT, UI_BORDER, true, false, false, true, 1, 0, 0, 0, ""};
  page.buttons[1] = {160, 60, 140, 40, "SAVE SETTINGS", "", UI_SUCCESS, UI_TEXT, UI_BORDER, true, false, false, true, 2, 0, 0, 0, ""};
  page.buttons[2] = {10, 110, 140, 40, "LOAD DEFAULTS", "", UI_INFO, UI_TEXT, UI_BORDER, true, false, false, true, 3, 0, 0, 0, ""};
  page.buttons[3] = {160, 110, 140, 40, "TEST TOUCH", "", UI_ACCENT, UI_TEXT, UI_BORDER, true, false, false, true, 4, 0, 0, 0, ""};
}

// ================================================================================
// ENHANCED DRAWING FUNCTIONS
// ================================================================================

void drawCurrentPage() {
  UIPage& page = pages[uiState.currentPage];
  
  if (uiState.needsFullRedraw || page.needsRedraw) {
    tft.fillScreen(UI_BG);
    drawHeader();
    drawPageContent(page);
    uiState.needsFullRedraw = false;
    page.needsRedraw = false;
  }
  
  if (uiState.showPageMenu) {
    drawPageMenu();
  }
}

void drawHeader() {
  // Header background
  tft.fillRect(0, 0, 320, 30, UI_HEADER);
  tft.drawLine(0, 30, 320, 30, UI_ACCENT);
  
  // Menu icon (top-left)
  tft.fillRect(5, 5, 20, 3, UI_TEXT);
  tft.fillRect(5, 10, 20, 3, UI_TEXT);
  tft.fillRect(5, 15, 20, 3, UI_TEXT);
  
  // Page title (center)
  tft.setTextColor(UI_TEXT);
  tft.setTextDatum(MC_DATUM);
  tft.drawString(pages[uiState.currentPage].title, 160, 15, 2);
  
  // System indicators (right)
  int x = 280;
  tft.fillCircle(x, 10, 3, systemState.wifiConnected ? UI_SUCCESS : UI_ERROR);
  tft.fillCircle(x + 12, 10, 3, systemState.sdCardMounted ? UI_SUCCESS : UI_ERROR);
  tft.fillCircle(x + 24, 10, 3, systemState.megaConnected ? UI_SUCCESS : UI_ERROR);
  
  // Health indicator
  tft.fillCircle(x, 20, 3, systemState.health > 80 ? UI_SUCCESS : systemState.health > 60 ? UI_WARNING : UI_ERROR);
}

void drawPageContent(UIPage& page) {
  // Draw all buttons
  for (int i = 0; i < page.buttonCount; i++) {
    if (page.buttons[i].visible) {
      drawButton(page.buttons[i]);
    }
  }
  
  // Draw all sliders
  for (int i = 0; i < page.sliderCount; i++) {
    if (page.sliders[i].enabled) {
      drawSlider(page.sliders[i]);
    }
  }
  
  // Draw page-specific content
  drawPageSpecificContent(page);
}

void drawButton(UIButton& btn) {
  if (!btn.visible) return;
  
  uint16_t bgColor = btn.pressed ? UI_BUTTON_PRESS : btn.selected ? UI_ACCENT : btn.bgColor;
  uint16_t textColor = btn.enabled ? btn.textColor : UI_TEXT_DIM;
  
  // Button background
  tft.fillRoundRect(btn.x, btn.y, btn.w, btn.h, 3, bgColor);
  tft.drawRoundRect(btn.x, btn.y, btn.w, btn.h, 3, btn.borderColor);
  
  // Button text
  tft.setTextColor(textColor);
  tft.setTextDatum(MC_DATUM);
  tft.drawString(btn.label, btn.x + btn.w / 2, btn.y + btn.h / 2 - 5, 1);
  
  // Button value (if any)
  if (btn.value.length() > 0) {
    tft.setTextColor(UI_TEXT_BRIGHT);
    tft.drawString(btn.value, btn.x + btn.w / 2, btn.y + btn.h / 2 + 5, 1);
  }
  
  // Disabled overlay
  if (!btn.enabled) {
    tft.drawLine(btn.x + 2, btn.y + 2, btn.x + btn.w - 2, btn.y + btn.h - 2, UI_ERROR);
  }
}

void drawSlider(UISlider& slider) {
  if (!slider.enabled) return;
  
  // Calculate fill width
  int fillWidth = map(slider.currentVal, slider.minVal, slider.maxVal, 0, slider.w);
  
  // Slider background
  tft.fillRoundRect(slider.x, slider.y, slider.w, slider.h, 2, slider.bgColor);
  tft.drawRoundRect(slider.x, slider.y, slider.w, slider.h, 2, UI_BORDER);
  
  // Slider fill
  if (fillWidth > 0) {
    tft.fillRoundRect(slider.x + 1, slider.y + 1, fillWidth - 2, slider.h - 2, 1, slider.fillColor);
  }
  
  // Handle
  int handleX = slider.x + fillWidth;
  tft.fillCircle(handleX, slider.y + slider.h / 2, 4, slider.handleColor);
  
  // Label
  tft.setTextColor(UI_TEXT);
  tft.setTextDatum(ML_DATUM);
  tft.drawString(slider.label, slider.x, slider.y - 12, 1);
  
  // Value
  String valueStr = String(slider.currentVal) + slider.unit;
  tft.setTextColor(UI_TEXT_BRIGHT);
  tft.setTextDatum(MR_DATUM);
  tft.drawString(valueStr, slider.x + slider.w, slider.y - 12, 1);
}

void drawPageMenu() {
  // Semi-transparent overlay
  tft.fillRect(0, 30, 150, 180, UI_PANEL);
  tft.drawRect(0, 30, 150, 180, UI_BORDER);
  
  String pageNames[] = {"Dashboard", "Relays", "Lighting", "DMX", "Audio", "Pixels", 
                       "Scenes", "Network", "System", "Diagnostics", "Calibration"};
  
  tft.setTextColor(UI_TEXT);
  tft.setTextDatum(ML_DATUM);
  
  for (int i = 0; i < PAGE_COUNT; i++) {
    int y = 40 + i * 16;
    if (i == (int)uiState.currentPage) {
      tft.fillRect(5, y - 8, 140, 16, UI_ACCENT);
      tft.setTextColor(UI_BG);
    } else {
      tft.setTextColor(UI_TEXT);
    }
    tft.drawString(pageNames[i], 10, y, 1);
  }
}

void drawPageSpecificContent(UIPage& page) {
  switch (page.type) {
    case PAGE_DASHBOARD:
      drawDashboardInfo();
      break;
    case PAGE_RELAYS:
      drawRelayStatus();
      break;
    case PAGE_DIAGNOSTICS:
      drawDiagnosticsInfo();
      break;
    case PAGE_PIXELS:
      drawPixelPreview();
      break;
    case PAGE_CALIBRATION:
      drawCalibrationInfo();
      break;
    default:
      break;
  }
}

void drawCalibrationInfo() {
  tft.setTextColor(UI_TEXT_DIM);
  tft.setTextDatum(ML_DATUM);
  
  int y = 160;
  tft.drawString("Touch Status:", 10, y, 1); y += 12;
  
  String calStatus = uiTouchCal.isCalibrated ? "Calibrated" : "Not Calibrated";
  uint16_t statusColor = uiTouchCal.isCalibrated ? UI_SUCCESS : UI_WARNING;
  tft.setTextColor(statusColor);
  tft.drawString("• " + calStatus, 20, y, 1); y += 12;
  
  if (uiTouchCal.isCalibrated) {
    tft.setTextColor(UI_TEXT_DIM);
    tft.drawString("• X Range: " + String(uiTouchCal.minX) + "-" + String(uiTouchCal.maxX), 20, y, 1); y += 12;
    tft.drawString("• Y Range: " + String(uiTouchCal.minY) + "-" + String(uiTouchCal.maxY), 20, y, 1); y += 12;
    tft.drawString("• Accuracy: ~" + String(testTouchAccuracy()) + "%", 20, y, 1); y += 12;
    
    if (uiTouchCal.swapXY || uiTouchCal.flipX || uiTouchCal.flipY) {
      tft.setTextColor(UI_WARNING);
      String transforms = "• Transforms: ";
      if (uiTouchCal.swapXY) transforms += "SwapXY ";
      if (uiTouchCal.flipX) transforms += "FlipX ";
      if (uiTouchCal.flipY) transforms += "FlipY";
      tft.drawString(transforms, 20, y, 1);
    }
  }
  
  // Show real-time touch data if touching
  if (uiState.touch.pressed) {
    tft.setTextColor(UI_ACCENT);
    tft.drawString("LIVE: (" + String(uiState.touch.x) + "," + String(uiState.touch.y) + ")", 200, 160, 1);
  }
}

void drawDashboardInfo() {
  tft.setTextColor(UI_TEXT_DIM);
  tft.setTextDatum(ML_DATUM);
  
  int y = 200;
  tft.drawString("Uptime: " + formatUptime((millis() - systemState.bootTime) / 1000), 10, y, 1);
  tft.drawString("Health: " + String(systemState.health) + "%", 120, y, 1);
  tft.drawString("Temp: " + String(systemState.temperature, 1) + "C", 200, y, 1);
}

void drawRelayStatus() {
  // Draw relay status indicators
  for (int i = 0; i < 8; i++) {
    int col = i % 4;
    int row = i / 4;
    int x = 10 + col * 75 + 35;
    int y = 60 + row * 45 + 45;
    
    // Status indicator
    uint16_t color = (pages[PAGE_RELAYS].buttons[i].value == "ON") ? UI_SUCCESS : UI_ERROR;
    tft.fillCircle(x, y, 3, color);
  }
}

void drawDiagnosticsInfo() {
  tft.setTextColor(UI_TEXT_DIM);
  tft.setTextDatum(ML_DATUM);
  
  int y = 130;
  tft.drawString("Free Heap: " + String(ESP.getFreeHeap() / 1024) + "KB", 10, y, 1); y += 15;
  tft.drawString("CPU Freq: " + String(ESP.getCpuFreqMHz()) + "MHz", 10, y, 1); y += 15;
  tft.drawString("Flash: " + String(ESP.getFlashChipSize() / 1024 / 1024) + "MB", 10, y, 1); y += 15;
  tft.drawString("Chip Rev: " + String(ESP.getChipRevision()), 10, y, 1); y += 15;
}

void drawPixelPreview() {
  // Draw pixel line preview
  for (int i = 0; i < 8; i++) {
    int x = 10 + i * 38;
    int y = 215;
    
    // Calculate color based on settings
    uint32_t color = systemState.pixelColors[i];
    uint8_t r = (color >> 16) & 0xFF;
    uint8_t g = (color >> 8) & 0xFF;
    uint8_t b = color & 0xFF;
    
    // Apply brightness
    r = (r * systemState.pixelBrightness[i]) / 255;
    g = (g * systemState.pixelBrightness[i]) / 255;
    b = (b * systemState.pixelBrightness[i]) / 255;
    
    uint16_t color565 = tft.color565(r, g, b);
    
    // Draw preview box
    tft.fillRect(x, y, 35, 20, color565);
    tft.drawRect(x, y, 35, 20, UI_BORDER);
    
    // Line number
    tft.setTextColor(UI_TEXT);
    tft.setTextDatum(MC_DATUM);
    tft.drawString(String(i + 1), x + 17, y + 10, 1);
  }
}

// ================================================================================
// BUTTON & SLIDER HANDLERS
// ================================================================================

void handleButtonPress(int buttonId, UIPageType pageType) {
  switch (pageType) {
    case PAGE_DASHBOARD:
      handleDashboardButton(buttonId);
      break;
    case PAGE_RELAYS:
      handleRelayButton(buttonId);
      break;
    case PAGE_LIGHTING:
      handleLightingButton(buttonId);
      break;
    case PAGE_DMX:
      handleDMXButton(buttonId);
      break;
    case PAGE_AUDIO:
      handleAudioButton(buttonId);
      break;
    case PAGE_PIXELS:
      handlePixelButton(buttonId);
      break;
    case PAGE_SCENES:
      handleSceneButton(buttonId);
      break;
    case PAGE_NETWORK:
      handleNetworkButton(buttonId);
      break;
    case PAGE_SYSTEM:
      handleSystemButton(buttonId);
      break;
    case PAGE_DIAGNOSTICS:
      handleDiagnosticsButton(buttonId);
      break;
    case PAGE_CALIBRATION:
      handleCalibrationButton(buttonId);
      break;
  }
}

void handleSliderChange(int sliderId, int newValue) {
  switch (uiState.currentPage) {
    case PAGE_DASHBOARD:
      if (sliderId == 1) systemState.masterVolume = newValue;
      else if (sliderId == 2) systemState.backlightBrightness = newValue;
      break;
    case PAGE_LIGHTING:
      // Handle lighting parameter changes
      sendMegaCommand("FX_PARAM:" + String(sliderId - 10) + ":" + String(newValue));
      break;
    case PAGE_DMX:
      if (sliderId >= 21 && sliderId <= 28) {
        systemState.dmxChannels[sliderId - 21] = newValue;
        sendMegaCommand("DMX_CH:" + String(sliderId - 20) + ":" + String(newValue));
      }
      break;
    case PAGE_AUDIO:
      if (sliderId == 31) systemState.masterVolume = newValue;
      else if (sliderId == 32) systemState.mp3_1_volume = newValue;
      else if (sliderId == 33) systemState.mp3_2_volume = newValue;
      sendMegaCommand("VOLUME:" + String(sliderId - 30) + ":" + String(newValue));
      break;
    case PAGE_PIXELS:
      if (sliderId >= 41 && sliderId <= 48) {
        systemState.pixelBrightness[sliderId - 41] = newValue;
        sendMegaCommand("PIXEL_BRIGHT:" + String(sliderId - 40) + ":" + String(newValue));
      }
      break;
    case PAGE_SYSTEM:
      if (sliderId == 91) {
        systemState.backlightBrightness = newValue;
        analogWrite(BACKLIGHT_PIN, newValue);
      }
      break;
  }
}

void handleDashboardButton(int buttonId) {
  switch (buttonId) {
    case 1: switchToPage(PAGE_RELAYS); break;
    case 2: switchToPage(PAGE_LIGHTING); break;
    case 3: switchToPage(PAGE_AUDIO); break;
    case 4: switchToPage(PAGE_SCENES); break;
    case 99: 
      sendMegaCommand("EMERGENCY_STOP");
      break;
  }
}

void handleRelayButton(int buttonId) {
  if (buttonId >= 1 && buttonId <= 8) {
    // Toggle individual relay
    UIButton& btn = pages[PAGE_RELAYS].buttons[buttonId - 1];
    bool newState = (btn.value != "ON");
    btn.value = newState ? "ON" : "OFF";
    btn.bgColor = newState ? UI_SUCCESS : UI_BUTTON;
    sendMegaCommand("RELAY:" + String(buttonId) + ":" + String(newState ? 1 : 0));
  } else if (buttonId == 91) {
    // All on
    for (int i = 0; i < 8; i++) {
      pages[PAGE_RELAYS].buttons[i].value = "ON";
      pages[PAGE_RELAYS].buttons[i].bgColor = UI_SUCCESS;
    }
    sendMegaCommand("RELAY:ALL:1");
  } else if (buttonId == 92) {
    // All off
    for (int i = 0; i < 8; i++) {
      pages[PAGE_RELAYS].buttons[i].value = "OFF";
      pages[PAGE_RELAYS].buttons[i].bgColor = UI_BUTTON;
    }
    sendMegaCommand("RELAY:ALL:0");
  }
}

void handleLightingButton(int buttonId) {
  if (buttonId >= 1 && buttonId <= 16) {
    sendMegaCommand("FX:" + String(buttonId));
    
    // Update button states
    for (int i = 0; i < 16; i++) {
      pages[PAGE_LIGHTING].buttons[i].selected = (i == buttonId - 1);
    }
  }
}

void handleDMXButton(int buttonId) {
  switch (buttonId) {
    case 1: // Enable
      systemState.dmxEnabled = true;
      sendMegaCommand("DMX_ENABLE");
      break;
    case 2: // Disable
      systemState.dmxEnabled = false;
      sendMegaCommand("DMX_DISABLE");
      break;
    case 3: // Blackout
      sendMegaCommand("DMX_BLACKOUT");
      break;
    case 4: // Preset
      sendMegaCommand("DMX_PRESET:1");
      break;
  }
}

void handleAudioButton(int buttonId) {
  String player = (buttonId <= 10) ? "1" : "2";
  int cmd = (buttonId > 10) ? buttonId - 10 : buttonId;
  
  switch (cmd) {
    case 1: sendMegaCommand("MP3_PLAY:" + player); break;
    case 2: sendMegaCommand("MP3_STOP:" + player); break;
    case 3: sendMegaCommand("MP3_NEXT:" + player); break;
    case 4: sendMegaCommand("MP3_PREV:" + player); break;
  }
  
  // Handle global controls
  if (buttonId == 21) { // Mute
    systemState.audioMuted = !systemState.audioMuted;
    sendMegaCommand("AUDIO_MUTE:" + String(systemState.audioMuted ? 1 : 0));
  }
}

void handlePixelButton(int buttonId) {
  if (buttonId >= 1 && buttonId <= 8) {
    // Color presets
    uint32_t colors[] = {0xFF0000, 0x00FF00, 0x0000FF, 0xFFFFFF, 0xFFFF00, 0x00FFFF, 0xFF00FF, 0xFFA500};
    uint32_t selectedColor = colors[buttonId - 1];
    
    // Apply to all enabled lines
    for (int i = 0; i < 8; i++) {
      if (systemState.pixelEnabled[i]) {
        systemState.pixelColors[i] = selectedColor;
        sendMegaCommand("PIXEL_COLOR:" + String(i + 1) + ":" + String(selectedColor, HEX));
      }
    }
  } else if (buttonId == 11) {
    // Apply to all lines
    for (int i = 0; i < 8; i++) {
      systemState.pixelEnabled[i] = true;
    }
  } else if (buttonId == 23) {
    // Turn all off
    for (int i = 0; i < 8; i++) {
      systemState.pixelBrightness[i] = 0;
      sendMegaCommand("PIXEL_BRIGHT:" + String(i + 1) + ":0");
    }
  }
}

void handleSceneButton(int buttonId) {
  if (buttonId >= 1 && buttonId <= 12) {
    sendMegaCommand("SCENE_PLAY:" + String(buttonId));
  } else if (buttonId == 92) {
    sendMegaCommand("SCENE_STOP");
  }
}

void handleNetworkButton(int buttonId) {
  switch (buttonId) {
    case 1: // Reconnect
      WiFi.reconnect();
      break;
    case 2: // AP Mode
      WiFi.mode(WIFI_AP);
      WiFi.softAP(AP_SSID, AP_PASSWORD);
      systemState.apMode = true;
      break;
    case 4: // Reset
      WiFi.disconnect();
      delay(1000);
      WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
      break;
  }
}

void handleSystemButton(int buttonId) {
  switch (buttonId) {
    case 1: // Reboot
      ESP.restart();
      break;
    case 2: // Factory reset
      // Clear settings
      break;
    case 13: // Calibrate
      switchToPage(PAGE_CALIBRATION);
      break;
  }
}

void handleDiagnosticsButton(int buttonId) {
  // Run diagnostic tests
  systemState.health = calculateSystemHealth();
  systemState.temperature = temperatureRead();
  systemState.freeHeap = ESP.getFreeHeap();
}

void handleCalibrationButton(int buttonId) {
  switch (buttonId) {
    case 1: // Start calibration
      startTouchCalibration();
      break;
    case 2: // Save settings
      saveTouchCalibration();
      break;
    case 3: // Load defaults
      loadDefaultCalibration();
      break;
    case 4: // Test touch
      uiState.inCalibrationMode = false;
      testTouchAccuracy();
      break;
  }
}

void startTouchCalibration() {
  uiState.inCalibrationMode = true;
  uiState.calibrationStep = 0;
  
  tft.fillScreen(UI_BG);
  tft.setTextColor(UI_TEXT_BRIGHT);
  tft.setTextDatum(MC_DATUM);
  tft.drawString("TOUCH CALIBRATION", 160, 30, 2);
  
  tft.setTextColor(UI_TEXT);
  tft.drawString("Touch the crosshair centers", 160, 60, 1);
  tft.drawString("precisely and hold briefly", 160, 75, 1);
  
  drawCalibrationCrosshair(0);
  
  Serial.println("🎯 Touch calibration started");
  Serial.println("   Touch each crosshair precisely in the center");
}

void drawCalibrationCrosshair(int step) {
  // Calibration points: corners + center
  uint16_t calPoints[5][2] = {
    {30, 30},    // Top-left
    {290, 30},   // Top-right  
    {290, 210},  // Bottom-right
    {30, 210},   // Bottom-left
    {160, 120}   // Center
  };
  
  if (step >= 5) {
    finishCalibration();
    return;
  }
  
  // Clear previous crosshair area
  if (step > 0) {
    tft.fillRect(calPoints[step-1][0] - 15, calPoints[step-1][1] - 15, 30, 30, UI_BG);
  }
  
  uint16_t x = calPoints[step][0];
  uint16_t y = calPoints[step][1];
  
  // Draw crosshair
  tft.drawLine(x - 10, y, x + 10, y, UI_ERROR);
  tft.drawLine(x, y - 10, x, y + 10, UI_ERROR);
  tft.drawCircle(x, y, 5, UI_WARNING);
  tft.drawCircle(x, y, 15, UI_ACCENT);
  
  // Draw step indicator
  tft.setTextColor(UI_TEXT_BRIGHT);
  tft.setTextDatum(MC_DATUM);
  tft.drawString("Step " + String(step + 1) + " of 5", 160, 200, 2);
  
  Serial.println("📍 Calibration step " + String(step + 1) + ": Touch crosshair at (" + String(x) + "," + String(y) + ")");
}

void processTouchCalibration(UITouchPoint touch) {
  if (!uiState.inCalibrationMode) return;
  
  static uint16_t rawCalPoints[5][2];
  static unsigned long lastCalTouch = 0;
  
  // Debounce calibration touches
  if (millis() - lastCalTouch < 500) return;
  lastCalTouch = millis();
  
  // Read raw coordinates for calibration
  uint16_t rawX, rawY;
  
  // Try to get actual raw coordinates from library
  TouchPoint libTouch = touchscreen.getTouch();
  if (libTouch.x > 100 && libTouch.x < 4000 && libTouch.y > 100 && libTouch.y < 4000) {
    rawX = libTouch.x;
    rawY = libTouch.y;
  } else {
    // Fallback: simulate raw coordinates based on touch position
    rawX = map(touch.x, 0, 320, uiTouchCal.minX, uiTouchCal.maxX);
    rawY = map(touch.y, 0, 240, uiTouchCal.minY, uiTouchCal.maxY);
  }
  
  // Store calibration point
  rawCalPoints[uiState.calibrationStep][0] = rawX;
  rawCalPoints[uiState.calibrationStep][1] = rawY;
  
  Serial.println("✅ Calibration point " + String(uiState.calibrationStep + 1) + 
                " captured: Raw(" + String(rawX) + "," + String(rawY) + ")");
  
  uiState.calibrationStep++;
  
  if (uiState.calibrationStep >= 5) {
    // Calculate calibration parameters
    calculateCalibration(rawCalPoints);
    finishCalibration();
  } else {
    drawCalibrationCrosshair(uiState.calibrationStep);
  }
}

void calculateCalibration(uint16_t rawPoints[5][2]) {
  // Calculate min/max from corner points
  uiTouchCal.minX = min(rawPoints[0][0], rawPoints[3][0]); // Top-left, Bottom-left
  uiTouchCal.maxX = max(rawPoints[1][0], rawPoints[2][0]); // Top-right, Bottom-right
  uiTouchCal.minY = min(rawPoints[0][1], rawPoints[1][1]); // Top-left, Top-right
  uiTouchCal.maxY = max(rawPoints[2][1], rawPoints[3][1]); // Bottom-right, Bottom-left
  
  // Check if X and Y are swapped by comparing ratios
  uint16_t xRange = uiTouchCal.maxX - uiTouchCal.minX;
  uint16_t yRange = uiTouchCal.maxY - uiTouchCal.minY;
  
  // If X range is much smaller than Y range, coordinates might be swapped
  if (xRange < yRange / 2) {
    uiTouchCal.swapXY = true;
    Serial.println("⚠️  X/Y coordinates appear to be swapped");
  }
  
  // Check if coordinates are flipped
  if (rawPoints[1][0] < rawPoints[0][0]) { // Top-right X < Top-left X
    uiTouchCal.flipX = true;
    Serial.println("⚠️  X coordinates appear to be flipped");
  }
  
  if (rawPoints[3][1] < rawPoints[0][1]) { // Bottom-left Y < Top-left Y  
    uiTouchCal.flipY = true;
    Serial.println("⚠️  Y coordinates appear to be flipped");
  }
  
  uiTouchCal.isCalibrated = true;
  
  Serial.println("🎯 Calibration calculated:");
  Serial.println("   X range: " + String(uiTouchCal.minX) + " - " + String(uiTouchCal.maxX));
  Serial.println("   Y range: " + String(uiTouchCal.minY) + " - " + String(uiTouchCal.maxY));
  Serial.println("   Swap XY: " + String(uiTouchCal.swapXY ? "Yes" : "No"));
  Serial.println("   Flip X: " + String(uiTouchCal.flipX ? "Yes" : "No"));
  Serial.println("   Flip Y: " + String(uiTouchCal.flipY ? "Yes" : "No"));
}

void finishCalibration() {
  uiState.inCalibrationMode = false;
  uiState.calibrationStep = 0;
  
  tft.fillScreen(UI_BG);
  tft.setTextColor(UI_SUCCESS);
  tft.setTextDatum(MC_DATUM);
  tft.drawString("CALIBRATION COMPLETE!", 160, 100, 3);
  
  tft.setTextColor(UI_TEXT);
  tft.drawString("Touch accuracy: " + String(testTouchAccuracy()) + "%", 160, 140, 2);
  tft.drawString("Touch anywhere to continue", 160, 170, 1);
  
  delay(2000);
  uiState.needsFullRedraw = true;
  
  Serial.println("✅ Touch calibration complete!");
}

void saveTouchCalibration() {
  // Save calibration to EEPROM or file
  if (systemState.sdCardMounted) {
    File calFile = SD.open("/touch_cal.txt", FILE_WRITE);
    if (calFile) {
      calFile.println("# ShowDuino Touch Calibration");
      calFile.println("minX=" + String(uiTouchCal.minX));
      calFile.println("maxX=" + String(uiTouchCal.maxX));
      calFile.println("minY=" + String(uiTouchCal.minY));
      calFile.println("maxY=" + String(uiTouchCal.maxY));
      calFile.println("swapXY=" + String(uiTouchCal.swapXY ? 1 : 0));
      calFile.println("flipX=" + String(uiTouchCal.flipX ? 1 : 0));
      calFile.println("flipY=" + String(uiTouchCal.flipY ? 1 : 0));
      calFile.println("calibrated=" + String(uiTouchCal.isCalibrated ? 1 : 0));
      calFile.close();
      
      Serial.println("💾 Touch calibration saved to SD card");
      
      // Update calibration page button
      pages[PAGE_CALIBRATION].buttons[1].value = "SAVED";
      pages[PAGE_CALIBRATION].buttons[1].bgColor = UI_SUCCESS;
    }
  }
}

void loadTouchCalibration() {
  if (systemState.sdCardMounted && SD.exists("/touch_cal.txt")) {
    File calFile = SD.open("/touch_cal.txt");
    if (calFile) {
      while (calFile.available()) {
        String line = calFile.readStringUntil('\n');
        line.trim();
        
        if (line.startsWith("minX=")) uiTouchCal.minX = line.substring(5).toInt();
        else if (line.startsWith("maxX=")) uiTouchCal.maxX = line.substring(5).toInt();
        else if (line.startsWith("minY=")) uiTouchCal.minY = line.substring(5).toInt();
        else if (line.startsWith("maxY=")) uiTouchCal.maxY = line.substring(5).toInt();
        else if (line.startsWith("swapXY=")) uiTouchCal.swapXY = line.substring(7).toInt();
        else if (line.startsWith("flipX=")) uiTouchCal.flipX = line.substring(6).toInt();
        else if (line.startsWith("flipY=")) uiTouchCal.flipY = line.substring(6).toInt();
        else if (line.startsWith("calibrated=")) uiTouchCal.isCalibrated = line.substring(11).toInt();
      }
      calFile.close();
      
      Serial.println("📁 Touch calibration loaded from SD card");
      systemState.touchCalibrated = true;
    }
  }
}

void loadDefaultCalibration() {
  uiTouchCal.minX = TOUCH_MIN_X;
  uiTouchCal.maxX = TOUCH_MAX_X;
  uiTouchCal.minY = TOUCH_MIN_Y;
  uiTouchCal.maxY = TOUCH_MAX_Y;
  uiTouchCal.swapXY = false;
  uiTouchCal.flipX = false;
  uiTouchCal.flipY = false;
  uiTouchCal.isCalibrated = false;
  
  Serial.println("🔄 Touch calibration reset to defaults");
  
  // Update calibration page button
  pages[PAGE_CALIBRATION].buttons[2].value = "LOADED";
  pages[PAGE_CALIBRATION].buttons[2].bgColor = UI_INFO;
}

int testTouchAccuracy() {
  // Simple accuracy test - return estimated accuracy percentage
  if (!uiTouchCal.isCalibrated) return 50;
  
  // Calculate accuracy based on calibration range reasonableness
  uint16_t xRange = uiTouchCal.maxX - uiTouchCal.minX;
  uint16_t yRange = uiTouchCal.maxY - uiTouchCal.minY;
  
  int accuracy = 70; // Base accuracy
  
  // Good range indicates better calibration
  if (xRange > 2000 && xRange < 4000) accuracy += 15;
  if (yRange > 2000 && yRange < 4000) accuracy += 15;
  
  return min(accuracy, 99);
}

// ================================================================================
// UTILITY FUNCTIONS
// ================================================================================

void switchToPage(UIPageType newPage) {
  if (newPage != uiState.currentPage) {
    uiState.currentPage = newPage;
    uiState.needsFullRedraw = true;
    uiState.lastPageChange = millis();
  }
}

void sendMegaCommand(String command) {
  SerialFromMega.println(command);
  Serial.println("Sent to Mega: " + command);
}

String formatUptime(unsigned long seconds) {
  if (seconds < 60) return String(seconds) + "s";
  if (seconds < 3600) return String(seconds / 60) + "m";
  if (seconds < 86400) return String(seconds / 3600) + "h";
  return String(seconds / 86400) + "d";
}

int calculateSystemHealth() {
  int score = 100;
  if (!systemState.wifiConnected) score -= 20;
  if (!systemState.sdCardMounted) score -= 15;
  if (!systemState.megaConnected) score -= 25;
  if (!systemState.touchInitialized) score -= 10;
  return max(0, score);
}

// ================================================================================
// MAIN SETUP & LOOP
// ================================================================================

void setup() {
  Serial.begin(115200);
  delay(2000);
  
  Serial.println("🎛️ ShowDuino ESP32 v2.1 - Enhanced Touch UI");
  Serial.println("============================================");
  Serial.println("📱 TOUCH UI FEATURES:");
  Serial.println("   • 11 comprehensive control pages");
  Serial.println("   • Individual pixel line brightness controls");
  Serial.println("   • Volume sliders for all audio channels");
  Serial.println("   • Real-time DMX channel control");
  Serial.println("   • Advanced scene management");
  Serial.println("   • System diagnostics & calibration");
  Serial.println("💡 TOUCH NOTE: Using basic touch detection");
  Serial.println("   Tap anywhere to navigate between pages");
  Serial.println("   Tap top-left corner for page menu");
  Serial.println("============================================");
  
  systemState.bootTime = millis();
  
  // Initialize hardware
  initializeGPIO();
  initializeTFT();
  initializeTouch();
  initializeSDCard();
  initializeWiFi();
  initializeWebServer();
  
  // Setup UI
  setupAllPages();
  
  // Load touch calibration
  loadTouchCalibration();
  
  Serial.println("🚀 SYSTEM READY - Enhanced Touch UI Active!");
  Serial.println("============================================");
  if (systemState.apMode) {
    Serial.println("📡 MODE: Access Point (AP)");
    Serial.println("🔗 Connect to: " + String(AP_SSID));
    Serial.println("🔑 Password: " + String(AP_PASSWORD));
  } else {
    Serial.println("📡 MODE: WiFi Client Connected");
  }
  Serial.println("🌐 Web Interface: http://" + systemState.ipAddress + "/");
  Serial.println("📱 API Endpoints: http://" + systemState.ipAddress + "/api/");
  Serial.println("🎯 Touch Status: " + String(systemState.touchCalibrated ? "Calibrated" : "Needs Calibration"));
  Serial.println("");
  Serial.println("📋 AVAILABLE API ENDPOINTS:");
  Serial.println("   GET  /api/status       - System status");
  Serial.println("   POST /api/relay        - Relay control");
  Serial.println("   POST /api/lighting     - Lighting effects");
  Serial.println("   POST /api/audio        - MP3 control");
  Serial.println("   POST /api/volume       - Volume control");
  Serial.println("   POST /api/pixels       - Pixel line control");
  Serial.println("   POST /api/scenes       - Scene management");
  Serial.println("   POST /api/dmx          - DMX channel control");
  Serial.println("   POST /api/emergency    - Emergency stop");
  Serial.println("   POST /api/system       - System control");
  Serial.println("");
  Serial.println("🎮 Your app can now control ShowDuino remotely!");
  Serial.println("============================================");
}

void initializeGPIO() {
  pinMode(CYD_LED_RED, OUTPUT);
  pinMode(CYD_LED_GREEN, OUTPUT);
  pinMode(CYD_LED_BLUE, OUTPUT);
  pinMode(BACKLIGHT_PIN, OUTPUT);
  pinMode(XPT2046_IRQ, INPUT_PULLUP);
  
  digitalWrite(BACKLIGHT_PIN, HIGH);
  digitalWrite(CYD_LED_GREEN, HIGH);
}

void initializeTFT() {
  tft.init();
  tft.setRotation(1);
  tft.fillScreen(UI_BG);
  
  // Startup animation
  for (int i = 0; i < 320; i += 40) {
    tft.drawLine(i, 0, i, 240, UI_ACCENT);
    delay(50);
  }
  
  tft.fillScreen(UI_BG);
  tft.setTextColor(UI_TEXT_BRIGHT);
  tft.setTextDatum(MC_DATUM);
  tft.drawString("SHOWDUINO v2.1", 160, 100, 4);
  tft.setTextColor(UI_TEXT);
  tft.drawString("Enhanced Touch Interface", 160, 130, 2);
  tft.drawString("Initializing...", 160, 150, 1);
  
  delay(2000);
  uiState.needsFullRedraw = true;
}

void initializeTouch() {
  touchscreen.begin();
  
  // Test basic touch detection
  systemState.touchInitialized = true;
  
  // Load saved calibration if available
  loadTouchCalibration();
  
  // Test touch screen basic functionality
  bool touchWorking = (digitalRead(XPT2046_IRQ) == HIGH); // Should be high when not touched
  
  if (touchWorking) {
    Serial.println("✅ Touch screen initialized successfully");
    Serial.println("   IRQ pin: " + String(XPT2046_IRQ) + " (state: " + String(digitalRead(XPT2046_IRQ)) + ")");
    
    if (uiTouchCal.isCalibrated) {
      Serial.println("📐 Touch calibration loaded:");
      Serial.println("   X: " + String(uiTouchCal.minX) + " - " + String(uiTouchCal.maxX));
      Serial.println("   Y: " + String(uiTouchCal.minY) + " - " + String(uiTouchCal.maxY));
      Serial.println("   Accuracy: ~" + String(testTouchAccuracy()) + "%");
      systemState.touchCalibrated = uiTouchCal.isCalibrated;
    } else {
      Serial.println("⚠️  Touch not calibrated - using defaults");
      Serial.println("   Go to Calibration page to improve accuracy");
    }
  } else {
    Serial.println("⚠️  Touch screen detected but may need calibration");
  }
  
  Serial.println("💡 TOUCH NAVIGATION:");
  Serial.println("   • Tap top-left corner for page menu");
  Serial.println("   • Touch buttons and sliders to control");
  Serial.println("   • Long press for context actions");
  Serial.println("   • Calibrate touch for best accuracy");
  Serial.println("");
  Serial.println("🔧 TROUBLESHOOTING:");
  Serial.println("   • If touch seems inaccurate: Go to Calibration page");
  Serial.println("   • If no response: Check IRQ pin connection");
  Serial.println("   • If coordinates wrong: Try different library methods");
  Serial.println("   • Watch serial output for touch debugging info");
}

void initializeSDCard() {
  SPI.begin(SD_SCK, SD_MISO, SD_MOSI, SD_CS);
  systemState.sdCardMounted = SD.begin(SD_CS);
  Serial.println(systemState.sdCardMounted ? "✅ SD Card mounted" : "❌ SD Card failed");
}

void initializeWiFi() {
  Serial.println("📶 Initializing WiFi...");
  
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    systemState.wifiConnected = true;
    systemState.apMode = false;
    systemState.ipAddress = WiFi.localIP().toString();
    
    Serial.println("\n✅ WiFi connected successfully!");
    Serial.println("📍 IP Address: " + systemState.ipAddress);
    Serial.println("🌐 Web Interface: http://" + systemState.ipAddress + "/");
    Serial.println("📱 API Base URL: http://" + systemState.ipAddress + "/api/");
  } else {
    Serial.println("\n❌ WiFi connection failed - Starting AP mode");
    
    WiFi.mode(WIFI_AP);
    bool apStarted = WiFi.softAP(AP_SSID, AP_PASSWORD);
    
    if (apStarted) {
      systemState.wifiConnected = false;
      systemState.apMode = true;
      systemState.ipAddress = WiFi.softAPIP().toString();
      
      Serial.println("🔶 ACCESS POINT MODE ACTIVE");
      Serial.println("╔════════════════════════════════════════╗");
      Serial.println("║          AP CONNECTION INFO            ║");
      Serial.println("╠════════════════════════════════════════╣");
      Serial.println("║ Network Name: " + String(AP_SSID) + "           ║");
      Serial.println("║ Password:     " + String(AP_PASSWORD) + "        ║");
      Serial.println("║ IP Address:   " + systemState.ipAddress + "            ║");
      Serial.println("║ Web Interface: http://" + systemState.ipAddress + "/     ║");
      Serial.println("║ API Base URL:  http://" + systemState.ipAddress + "/api/ ║");
      Serial.println("╚════════════════════════════════════════╝");
      Serial.println("📱 Connect your device to the AP network above");
      Serial.println("🎛️ Then open the web interface to control ShowDuino");
      Serial.println("⚡ Your app can now connect to: " + systemState.ipAddress);
    } else {
      Serial.println("❌ Failed to start AP mode");
      systemState.ipAddress = "0.0.0.0";
    }
  }
}

void initializeWebServer() {
  server.on("/", HTTP_GET, []() {
    String html = getWebInterface();
    server.send(200, "text/html", html);
  });
  
  // Comprehensive API endpoints for app control
  server.on("/api/status", HTTP_GET, handleAPIStatus);
  server.on("/api/relay", HTTP_POST, handleAPIRelay);
  server.on("/api/relay", HTTP_GET, handleAPIRelayStatus);
  server.on("/api/lighting", HTTP_POST, handleAPILighting);
  server.on("/api/dmx", HTTP_POST, handleAPIDMX);
  server.on("/api/audio", HTTP_POST, handleAPIAudio);
  server.on("/api/volume", HTTP_POST, handleAPIVolume);
  server.on("/api/pixels", HTTP_POST, handleAPIPixels);
  server.on("/api/scenes", HTTP_POST, handleAPIScenes);
  server.on("/api/emergency", HTTP_POST, handleAPIEmergency);
  server.on("/api/system", HTTP_POST, handleAPISystem);
  server.on("/api/calibration", HTTP_POST, handleAPICalibration);
  
  // CORS preflight for all API endpoints
  server.on("/api/status", HTTP_OPTIONS, handleCORS);
  server.on("/api/relay", HTTP_OPTIONS, handleCORS);
  server.on("/api/lighting", HTTP_OPTIONS, handleCORS);
  server.on("/api/dmx", HTTP_OPTIONS, handleCORS);
  server.on("/api/audio", HTTP_OPTIONS, handleCORS);
  server.on("/api/volume", HTTP_OPTIONS, handleCORS);
  server.on("/api/pixels", HTTP_OPTIONS, handleCORS);
  server.on("/api/scenes", HTTP_OPTIONS, handleCORS);
  server.on("/api/emergency", HTTP_OPTIONS, handleCORS);
  server.on("/api/system", HTTP_OPTIONS, handleCORS);
  server.on("/api/calibration", HTTP_OPTIONS, handleCORS);
  
  server.begin();
  Serial.println("✅ Web server started with comprehensive API");
  Serial.println("📱 API Base URL: http://" + systemState.ipAddress + "/api/");
}

void handleCORS() {
  server.sendHeader("Access-Control-Allow-Origin", "*");
  server.sendHeader("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
  server.sendHeader("Access-Control-Allow-Headers", "Content-Type");
  server.send(200);
}

String getWebInterface() {
  String html = "<!DOCTYPE html><html><head>";
  html += "<title>ShowDuino Control Panel</title>";
  html += "<meta name='viewport' content='width=device-width,initial-scale=1'>";
  html += "<style>";
  html += "body{font-family:Arial;margin:20px;background:#1a1a1a;color:#00ff00;}";
  html += ".container{max-width:800px;margin:0 auto;}";
  html += ".status{background:#2a2a2a;padding:15px;border-radius:5px;margin:10px 0;}";
  html += ".controls{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:15px;}";
  html += ".control-group{background:#2a2a2a;padding:15px;border-radius:5px;}";
  html += "button{background:#007700;color:white;border:none;padding:10px 20px;border-radius:3px;cursor:pointer;}";
  html += "button:hover{background:#009900;}";
  html += "input[type=range]{width:100%;margin:10px 0;}";
  html += ".emergency{background:#770000!important;}";
  html += "</style>";
  html += "</head><body>";
  
  html += "<div class='container'>";
  html += "<h1>🎛️ ShowDuino Control Panel</h1>";
  
  // System Status
  html += "<div class='status'>";
  html += "<h3>System Status</h3>";
  html += "<p>WiFi: <span id='wifi'>" + String(systemState.wifiConnected ? "Connected" : "AP Mode") + "</span></p>";
  html += "<p>IP: <span id='ip'>" + systemState.ipAddress + "</span></p>";
  html += "<p>Health: <span id='health'>" + String(systemState.health) + "%</span></p>";
  html += "<p>Touch UI: <span id='touchui'>Enhanced 11-Page Interface Active</span></p>";
  html += "</div>";
  
  // Quick Controls
  html += "<div class='controls'>";
  
  // Relay Controls
  html += "<div class='control-group'>";
  html += "<h4>Relay Control</h4>";
  for (int i = 1; i <= 8; i++) {
    html += "<button onclick='toggleRelay(" + String(i) + ")'>Relay " + String(i) + "</button>";
  }
  html += "<button onclick='relayAll(1)'>All ON</button>";
  html += "<button onclick='relayAll(0)'>All OFF</button>";
  html += "</div>";
  
  // Audio Controls
  html += "<div class='control-group'>";
  html += "<h4>Audio Control</h4>";
  html += "<label>Master Volume: <input type='range' id='masterVol' min='0' max='100' value='" + String(systemState.masterVolume) + "' onchange='setVolume(0,this.value)'></label>";
  html += "<label>MP3-1 Volume: <input type='range' id='mp3Vol1' min='0' max='100' value='" + String(systemState.mp3_1_volume) + "' onchange='setVolume(1,this.value)'></label>";
  html += "<label>MP3-2 Volume: <input type='range' id='mp3Vol2' min='0' max='100' value='" + String(systemState.mp3_2_volume) + "' onchange='setVolume(2,this.value)'></label>";
  html += "<button onclick='audioControl(1,\"play\")'>Play MP3-1</button>";
  html += "<button onclick='audioControl(1,\"stop\")'>Stop MP3-1</button>";
  html += "<button onclick='audioControl(2,\"play\")'>Play MP3-2</button>";
  html += "<button onclick='audioControl(2,\"stop\")'>Stop MP3-2</button>";
  html += "</div>";
  
  // Lighting Controls
  html += "<div class='control-group'>";
  html += "<h4>Lighting Effects</h4>";
  html += "<button onclick='lightingEffect(1)'>Chase</button>";
  html += "<button onclick='lightingEffect(2)'>Fade</button>";
  html += "<button onclick='lightingEffect(3)'>Strobe</button>";
  html += "<button onclick='lightingEffect(4)'>Rainbow</button>";
  html += "<button onclick='lightingEffect(0)'>All OFF</button>";
  html += "</div>";
  
  // Pixel Controls
  html += "<div class='control-group'>";
  html += "<h4>Pixel Lines</h4>";
  for (int i = 1; i <= 4; i++) {
    html += "<label>Line " + String(i) + " Brightness: <input type='range' id='pixel" + String(i) + "' min='0' max='255' value='" + String(systemState.pixelBrightness[i-1]) + "' onchange='setPixelBrightness(" + String(i) + ",this.value)'></label>";
  }
  html += "<button onclick='pixelColor(\"FF0000\")'>Red</button>";
  html += "<button onclick='pixelColor(\"00FF00\")'>Green</button>";
  html += "<button onclick='pixelColor(\"0000FF\")'>Blue</button>";
  html += "<button onclick='pixelColor(\"000000\")'>OFF</button>";
  html += "</div>";
  
  // Scene Controls
  html += "<div class='control-group'>";
  html += "<h4>Scene Control</h4>";
  for (int i = 1; i <= 6; i++) {
    html += "<button onclick='playScene(" + String(i) + ")'>Scene " + String(i) + "</button>";
  }
  html += "<button onclick='stopScenes()'>Stop All</button>";
  html += "</div>";
  
  // Emergency Controls
  html += "<div class='control-group'>";
  html += "<h4>Emergency</h4>";
  html += "<button class='emergency' onclick='emergency()'>EMERGENCY STOP</button>";
  html += "<button onclick='systemReboot()'>Reboot System</button>";
  html += "</div>";
  
  html += "</div>"; // controls
  
  // JavaScript for API calls
  html += "<script>";
  html += "function apiCall(endpoint, data) {";
  html += "  fetch('/api/' + endpoint, {";
  html += "    method: 'POST',";
  html += "    headers: {'Content-Type': 'application/json'},";
  html += "    body: JSON.stringify(data)";
  html += "  }).then(r => r.json()).then(d => console.log(d));";
  html += "}";
  
  html += "function toggleRelay(id) { apiCall('relay', {relay: id, action: 'toggle'}); }";
  html += "function relayAll(state) { apiCall('relay', {relay: 'all', state: state}); }";
  html += "function setVolume(channel, value) { apiCall('volume', {channel: channel, value: value}); }";
  html += "function audioControl(player, action) { apiCall('audio', {player: player, action: action}); }";
  html += "function lightingEffect(effect) { apiCall('lighting', {effect: effect}); }";
  html += "function setPixelBrightness(line, value) { apiCall('pixels', {line: line, brightness: value}); }";
  html += "function pixelColor(color) { apiCall('pixels', {action: 'color', color: color}); }";
  html += "function playScene(scene) { apiCall('scenes', {action: 'play', scene: scene}); }";
  html += "function stopScenes() { apiCall('scenes', {action: 'stop'}); }";
  html += "function emergency() { if(confirm('EMERGENCY STOP?')) apiCall('emergency', {}); }";
  html += "function systemReboot() { if(confirm('Reboot system?')) apiCall('system', {action: 'reboot'}); }";
  
  // Auto-refresh status
  html += "setInterval(() => {";
  html += "  fetch('/api/status').then(r => r.json()).then(d => {";
  html += "    document.getElementById('health').textContent = d.health + '%';";
  html += "  });";
  html += "}, 5000);";
  
  html += "</script>";
  html += "</div></body></html>";
  
  return html;
}

void loop() {
  // Handle web server
  server.handleClient();
  
  // Update touch input
  updateTouchState();
  
  // Update display
  if (millis() - lastDisplayUpdate > DISPLAY_UPDATE_INTERVAL) {
    drawCurrentPage();
    lastDisplayUpdate = millis();
  }
  
  // Update system status
  if (millis() - lastStatusUpdate > STATUS_UPDATE_INTERVAL) {
    updateSystemStatus();
    lastStatusUpdate = millis();
  }
  
  delay(10);
}

void updateSystemStatus() {
  // Update connection states
  systemState.wifiConnected = (WiFi.status() == WL_CONNECTED);
  systemState.health = calculateSystemHealth();
  systemState.temperature = temperatureRead();
  systemState.freeHeap = ESP.getFreeHeap();
  
  // Update status indicators on buttons
  if (uiState.currentPage == PAGE_DASHBOARD) {
    pages[PAGE_DASHBOARD].buttons[4].bgColor = systemState.wifiConnected ? UI_SUCCESS : UI_ERROR;
    pages[PAGE_DASHBOARD].buttons[5].bgColor = systemState.sdCardMounted ? UI_SUCCESS : UI_ERROR;
    pages[PAGE_DASHBOARD].buttons[6].bgColor = systemState.megaConnected ? UI_SUCCESS : UI_ERROR;
    
    // Update status button values
    pages[PAGE_DASHBOARD].buttons[4].value = systemState.wifiConnected ? "CONNECTED" : "FAILED";
    pages[PAGE_DASHBOARD].buttons[5].value = systemState.sdCardMounted ? "OK" : "FAILED";
    pages[PAGE_DASHBOARD].buttons[6].value = systemState.megaConnected ? "ONLINE" : "OFFLINE";
  }
  
  // Update network page IP display
  if (uiState.currentPage == PAGE_NETWORK) {
    pages[PAGE_NETWORK].buttons[7].label = "IP: " + systemState.ipAddress;
  }
}
