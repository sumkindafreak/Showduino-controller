#include <Wire.h>
#include <SparkFunSX1509.h>
#include <Arduino.h>
#include <Adafruit_NeoPixel.h>
#include "Adafruit-NECremote44.h"
#include <RTClib.h>
#include <DHT.h>
#include <CuteBuzzerSounds.h>
#include "custom_neopixel_fx.h"


#define PIXEL_COUNT 24
#define NUM_RELAYS 8
#define NUM_PIXEL_LINES 4

// Pin Assignments for diagnostics

#define PWR_OK_PIN A4     // Gray wire (Power Good Signal)
#define VOLTAGE_12V A5    // Yellow wire (12V) - DISABLED UNTIL SENSOR ARRIVES
#define VOLTAGE_5V A1     // Red wire (5V) - Direct Connection
#define VOLTAGE_3V3 A2    // Orange wire (3.3V) - Direct Connection
#define STANDBY_POWER A3  // Purple wire (5VSB - Standby Power)

#define BUZZER_PIN 47

RTC_DS1307 rtc;


// ===== Voltage Thresholds =====
const float THRESHOLD_5V = 4.7;
const float THRESHOLD_3V3 = 3.1;
const float THRESHOLD_5VSB = 4.7;
const float THRESHOLD_PWR_OK = 4.5;
const float THRESHOLD_12V = 11.5;
float voltageMultiplier = 5.0 * (25.0 / 5.0) / 1023.0;  // Already correct for the module

#define DHTPIN 48      // DHT11 data pin
#define DHTTYPE DHT11  // Sensor type

DHT dht(DHTPIN, DHTTYPE);
unsigned long lastDHTLog = 0;
const unsigned long DHT_INTERVAL = 20000;  // 40 seconds





const int START_BTN_PIN = 6;
const int RESET_BTN_PIN = 7;
const int STOP_BTN_PIN = 8;

bool lastStartState = HIGH;
bool lastResetState = HIGH;
bool lastStopState = HIGH;

const unsigned long btnDebounce = 50;
unsigned long lastBtnTime = 0;

SX1509 io;
#define SX_ADDR 0x3E
// Remap SX1509 pin index [0â€“9] to the actual scene button number
const byte sxSceneButtons[16] = {
  0,   // Pin 0 â†’ Button 0
  7,   // Pin 1 â†’ Button 1
  8,   // Pin 2 â†’ Button 2
  9,   // Pin 3 â†’ Button 3
  4,   // Pin 4 â†’ Button 4
  5,   // Pin 5 â†’ Button 5
  6,   // Pin 6 â†’ Button 6
  1,   // Pin 7 â†’ Button 7
  2,   // Pin 8 â†’ Button 8
  3,   // Pin 9 â†’ Button 9
  10,  // Pin 10 â†’ input 10
  11,  // Pin 11 â†’ input 11
  12,  // Pin 12 â†’ input 12
  13,  // Pin 13 â†’ input 13
  14,  // Pin 14 â†’ input 14
  15,  // Pin 15 â†’ input 15
};


const int numSceneButtons = sizeof(sxSceneButtons) / sizeof(sxSceneButtons[0]);
bool sxPrevState[16] = { HIGH };  // Fills all to HIGH


// --- NeoPixels (D22â€“D25)
const int pixelPins[NUM_PIXEL_LINES] = { 22, 23, 24, 25 };
Adafruit_NeoPixel pixels[NUM_PIXEL_LINES] = {
  Adafruit_NeoPixel(PIXEL_COUNT, 22, NEO_GRB + NEO_KHZ800),
  Adafruit_NeoPixel(PIXEL_COUNT, 23, NEO_GRB + NEO_KHZ800),
  Adafruit_NeoPixel(PIXEL_COUNT, 24, NEO_GRB + NEO_KHZ800),
  Adafruit_NeoPixel(PIXEL_COUNT, 25, NEO_GRB + NEO_KHZ800)
};

// --- Relays (D26â€“D33)
const int relayPins[NUM_RELAYS] = { 26, 27, 28, 29, 30, 31, 32, 33 };
bool relayStates[NUM_RELAYS];

bool relayUseTimer[NUM_RELAYS] = { false, false, false, false, false, false, false, false };
unsigned long relayTimers[NUM_RELAYS] = { 0 };
const unsigned long relayDuration = 3000;  // 3 seconds


#define NUM_BUTTONS 12  // Previously 8


const int buttonPins[NUM_BUTTONS] = {
  40, 41, 42, 43, 44, 45, 34, 35,  // Buttons 0â€“7 â†’ Relays 1â€“7
  36, 37, 38, 39                   // Buttons 8â€“11 â†’ A, B, C, Relay 8
};

bool buttonStates[NUM_BUTTONS] = { HIGH };  // Auto fills all HIGHs
unsigned long lastDebounceTime[NUM_BUTTONS] = { 0 };
const unsigned long debounceDelay = 50;

// --- IR Remote on Pin 46
const byte irPin = 46;
Adafruit_NECremote remote(irPin);

// Hex codes for IR buttons
const byte buttonCode[44] = {
  0x5C, 0x5D, 0x41, 0x40, 0x58, 0x59, 0x45, 0x44,
  0x54, 0x55, 0x49, 0x48, 0x50, 0x51, 0x4D, 0x4C,
  0x1C, 0x1D, 0x1E, 0x1F, 0x18, 0x19, 0x1A, 0x1B,
  0x14, 0x15, 0x16, 0x17, 0x10, 0x11, 0x12, 0x13,
  0x0C, 0x0D, 0x0E, 0x0F, 0x08, 0x09, 0x0A, 0x0B,
  0x04, 0x05, 0x06, 0x07
};

// Readable labels for each button
const char* irLabels[44] = {
  "1", "2", "3", "4",
  "5", "6", "7", "8",
  "9", "0", "*", "#",
  "A", "B", "C", "D",
  "E", "F", "G", "H",
  "I", "J", "K", "L",
  "M", "N", "O", "P",
  "Q", "R", "S", "T",
  "U", "V", "W", "X",
  "Y", "Z", "RED", "GREEN",
  "BLUE", "YELLOW", "UP", "DOWN"
};


bool sceneRunning = false;
void checkControlButtons() {
  if (millis() - lastBtnTime < btnDebounce) return;

  bool startState = digitalRead(START_BTN_PIN);
  bool resetState = digitalRead(RESET_BTN_PIN);
  bool stopState = digitalRead(STOP_BTN_PIN);

  // START button toggles scene on/off
  if (startState == LOW && lastStartState == HIGH) {
    sceneRunning = !sceneRunning;
    if (sceneRunning) {
      Serial.println("[BTN] START pressed â†’ Scene STARTED");
      // Add start scene logic here
    } else {
      Serial.println("[BTN] START pressed â†’ Scene STOPPED");
      // Add stop scene logic here
    }
    lastBtnTime = millis();
  }

  // EMERGENCY STOP
  if (stopState == LOW && lastStopState == HIGH) {
    Serial.println("[BTN] EMERGENCY STOP triggered");
    sceneRunning = false;
    // Add emergency stop logic here (turn off everything NOW)
    lastBtnTime = millis();
  }

  // RESET
  if (resetState == LOW && lastResetState == HIGH) {
    Serial.println("[BTN] RESET pressed");
    sceneRunning = false;
    // Add reset logic here
    lastBtnTime = millis();
  }

  lastStartState = startState;
  lastResetState = resetState;
  lastStopState = stopState;
}





void setupRTC() {
  Wire.begin();

  if (!rtc.begin()) {
    Serial.println("[RTC] Couldn't find DS1307. Check wiring.");
    // while (1);  // halt
  }

  if (!rtc.isrunning()) {
    Serial.println("[RTC] Clock is NOT running. Setting to compile time.");
    rtc.adjust(DateTime(F(__DATE__), F(__TIME__)));
  }

  Serial.println("[RTC] DS1307 Initialized.");
}

void sendToESP(const String& message) {
  Serial.println("[TO ESP] " + message);
  Serial1.println("@ESP: " + message);
}


void setupSerialComms() {
  Serial.begin(9600);
  Serial1.begin(115200);
  delay(100);
  sendToESP("{SYS} Mega is online.");
}













// === SETUP ===



/*/ CURRENT BUZZER OPTIONS: 
 
 
 S_CONNECTION   S_DISCONNECTION S_BUTTON_PUSHED   
 S_MODE1        S_MODE2         S_MODE3     
 S_SURPRISE     S_OHOOH         S_OHOOH2    
 S_CUDDLY       S_SLEEPING      S_HAPPY     
 S_SUPER_HAPPY  S_HAPPY_SHORT   S_SAD       
 S_CONFUSED     S_FART1         S_FART2     
 S_FART3        S_JUMP 20

 */






void setup() {
  cute.init(BUZZER_PIN);
  cute.play(S_CONNECTION);
  Serial.begin(115200);   // USB serial monitor
  Serial1.begin(115200);  // To ESP32 via Serial1 (TX1=18, RX1=19)
  delay(1000);
  Serial.println("[MEGA] Mega booted");
  Serial1.println("@ESP: Mega booted");


  setupRTC();  // â† Tidy and modular
  logVoltageDiagnostics();
  if (!io.begin(SX_ADDR)) {
    Serial.println("[ERROR] SX1509 not detected.");
  } else {
    Serial.println("[OK] SX1509 online.");
    for (int i = 0; i < numSceneButtons; i++) {
      io.pinMode(sxSceneButtons[i], INPUT_PULLUP);
    }
  }
  for (int i = 0; i < NUM_RELAYS; i++) {
    pinMode(relayPins[i], OUTPUT);
    digitalWrite(relayPins[i], LOW);
    relayStates[i] = false;
  }

  for (int i = 0; i < NUM_PIXEL_LINES; i++) {
    pixels[i].begin();
    pixels[i].clear();
    pixels[i].show();
  }

  pinMode(START_BTN_PIN, INPUT_PULLUP);
  pinMode(RESET_BTN_PIN, INPUT_PULLUP);
  pinMode(STOP_BTN_PIN, INPUT_PULLUP);
  dht.begin();
  Serial.println("[DHT] Sensor initialized.");


  for (int i = 0; i < NUM_BUTTONS; i++) {
    pinMode(buttonPins[i], INPUT_PULLUP);
  }

  pinMode(irPin, INPUT);
  Serial.println("Showduino Mega Booted");
}








// === END OF SETUP ===










void loop() {
  checkButtons();         // Your relay buttons
  checkControlButtons();  // New START/STOP/RESET buttons
  checkSX1509Buttons();   // Scene buttons (0â€“9)
  checkIR();              // Remote
  logDHTData();           // Check and log every 40s
  checkSerial();
  // Auto-off check
  // Check for timed relay auto-OFF
  for (int i = 0; i < NUM_RELAYS; i++) {
    if (relayUseTimer[i] && relayStates[i]) {
      if (millis() - relayTimers[i] >= relayDuration) {
        digitalWrite(relayPins[i], LOW);
        relayStates[i] = false;
        Serial.print("[TIMER] RELAY_");
        Serial.print(i + 1);
        Serial.println(" AUTO-OFF");
      }
    }
  }


  // Read from Serial Monitor, send to ESP
  if (Serial.available()) {
    String msg = Serial.readStringUntil('\n');
    Serial1.println("@ESP: " + msg);
    Serial.println("[MEGA] Sent to ESP: " + msg);
  }

  // Read from ESP32, act on commands
  if (Serial1.available()) {
    String msg = Serial1.readStringUntil('\n');
    msg.trim();
    Serial.println("[MEGA] ESP says: " + msg);
    handleCommand(msg);  // â† This runs your relay logic!
  }

  // === IR Remote Polling ===
  if (digitalRead(irPin) == LOW) {
    int code = remote.listen(-1);
    if (code >= 0) {
      for (int i = 0; i < 44; i++) {
        if (buttonCode[i] == code) {
          Serial.print("[IR] ");
          Serial.println(irLabels[i]);
          break;
        }
      }
    }
  }
}












// === END OF LOOP ===











// ===============888888888888888888============ WORKING LOGIC Do .Not .Touch! =================8888888======================

void logDHTData() {
  if (millis() - lastDHTLog >= DHT_INTERVAL) {
    lastDHTLog = millis();

    float h = dht.readHumidity();
    float t = dht.readTemperature();

    if (isnan(h) || isnan(t)) {
      Serial.println("[DHT] Failed to read from sensor!");
    } else {
      Serial.print("[DHT] Temp: ");
      Serial.print(t, 1);
      Serial.print("Â°C  Humidity: ");
      Serial.print(h, 1);
      Serial.println("%");
    }
  }
}

void checkButtons() {
  for (int i = 0; i < NUM_BUTTONS; i++) {
    int reading = digitalRead(buttonPins[i]);

    if (reading != buttonStates[i] && (millis() - lastDebounceTime[i]) > debounceDelay) {
      lastDebounceTime[i] = millis();
      buttonStates[i] = reading;

      if (reading == LOW) {
        if (i <= 6) {
          // Relays 1â€“7 (Button 0â€“6)
          toggleRelay(i);
        } else if (i == 11) {
          // Relay 8 (Button 11)
          toggleRelay(7);
        } else {
          // Buttons Aâ€“C (Buttons 7â€“10)
          char label = 'A' + (i - 7);  // Maps i=7â†’A, i=8â†’B, i=9â†’C, i=10â†’D
          Serial.print("[BTN] Button ");
          Serial.print(label);
          Serial.println(" Pressed");
        }
      }
    }
  }
}
void checkSX1509Buttons() {
  for (int i = 0; i < numSceneButtons; i++) {
    int pin = sxSceneButtons[i];
    bool state = io.digitalRead(pin);
    if (state != sxPrevState[i]) {
      sxPrevState[i] = state;
      if (state == LOW) {
        Serial.print("[MANUAL] Scene Button ");
        Serial.print(i);
        Serial.println(" Pressed");

        // ðŸ – Send to ESP as a trigger message
        Serial1.print("SXBTN_");
        Serial1.print(i);
        Serial1.println("_TRIGGER");
      }
    }
  }
}

void toggleRelay(int num) {
  if (relayUseTimer[num]) {
    // TIMED MODE: trigger ON for X ms
    digitalWrite(relayPins[num], HIGH);
    relayStates[num] = true;
    relayTimers[num] = millis();
    Serial.print("[TIMER] RELAY_");
    Serial.print(num + 1);
    Serial.println(" ON");
  } else {
    // MANUAL MODE: toggle state
    relayStates[num] = !relayStates[num];
    digitalWrite(relayPins[num], relayStates[num] ? HIGH : LOW);
    Serial.print("[MANUAL] RELAY_");
    Serial.print(num + 1);
    Serial.print(" ");
    Serial.println(relayStates[num] ? "ON" : "OFF");
  }
}
void handleCommand(String cmd) {
  Serial.println(">> CMD: " + cmd);

  if (cmd.startsWith("RELAY_")) {
    int r = cmd.substring(6, 7).toInt() - 1;

    if (r >= 0 && r < NUM_RELAYS) {
      if (cmd.endsWith("_ON")) {
        digitalWrite(relayPins[r], HIGH);
        relayStates[r] = true;
        if (relayUseTimer[r]) relayTimers[r] = millis();
        Serial.print("[OK] RELAY_");
        Serial.print(r + 1);
        Serial.println(" ON");

      } else if (cmd.endsWith("_OFF")) {
        digitalWrite(relayPins[r], LOW);
        relayStates[r] = false;
        Serial.print("[OK] RELAY_");
        Serial.print(r + 1);
        Serial.println(" OFF");

      } else if (cmd.endsWith("_TIMER_ON")) {
        relayUseTimer[r] = true;
        Serial.print("[TIMER] RELAY_");
        Serial.print(r + 1);
        Serial.println(" â†’ TIMED");

      } else if (cmd.endsWith("_TIMER_OFF")) {
        relayUseTimer[r] = false;
        Serial.print("[TIMER] RELAY_");
        Serial.print(r + 1);
        Serial.println(" â†’ MANUAL");

      } else if (cmd.startsWith("SXBTN_") && cmd.endsWith("_TRIGGER")) {
        int button = cmd.substring(6, cmd.indexOf("_TRIGGER")).toInt();
        Serial.print("[SX] Remote Scene Trigger for Button ");
        Serial.println(button);

        // ðŸŽ¯ Eventually trigger `loadScene(button);`
      }
    }
  }



  // === Timer Control ===
  else if (cmd.startsWith("RELAY_") && cmd.endsWith("_TIMER_ON")) {
    int r = cmd.substring(6, 7).toInt() - 1;
    if (r >= 0 && r < NUM_RELAYS) {
      relayUseTimer[r] = true;
      Serial.print("[OK] RELAY_");
      Serial.print(r + 1);
      Serial.println(" TIMED MODE ENABLED");
    }
  } else if (cmd.startsWith("RELAY_") && cmd.endsWith("_TIMER_OFF")) {
    int r = cmd.substring(6, 7).toInt() - 1;
    if (r >= 0 && r < NUM_RELAYS) {
      relayUseTimer[r] = false;
      Serial.print("[OK] RELAY_");
      Serial.print(r + 1);
      Serial.println(" TOGGLE MODE ENABLED");
    }
  }
}
void checkIR() {
  // IR logic already handled in loop (optional placeholder)
}
void checkSerial() {
  if (Serial.available()) {
    String cmd = Serial.readStringUntil('\n');
    cmd.trim();
    handleCommand(cmd);
  }
}

void logVoltageDiagnostics() {
  float v5V = analogRead(VOLTAGE_5V) * (5.0 / 1023.0);
  float v3V3 = analogRead(VOLTAGE_3V3) * (5.0 / 1023.0);
  float vSB = analogRead(STANDBY_POWER) * (5.0 / 1023.0);
  float pwrOK = analogRead(PWR_OK_PIN) * (5.0 / 1023.0);
  float v12V = analogRead(VOLTAGE_12V) * voltageMultiplier;

  Serial.println("[VOLTAGE] Diagnostics:");
  Serial.println("  - 5V Line      : " + String(v5V, 2) + " V");
  Serial.println("  - 3.3V Line    : " + String(v3V3, 2) + " V");
  Serial.println("  - 5V Standby   : " + String(vSB, 2) + " V");
  Serial.println("  - PWR_OK Line  : " + String(pwrOK, 2) + " V");
  Serial.println("  - 12V Sensor   : " + String(v12V, 2) + " V");

  // Optional: Add warnings
  if (v5V < 4.5) Serial.println("  âš ï¸  WARNING: 5V rail under-voltage!");
  if (v3V3 < 3.0) Serial.println("  âš ï¸  WARNING: 3.3V rail under-voltage!");
  if (v12V < 11.0) Serial.println("  âš ï¸  WARNING: 12V sensor line low!");
}
