#include <SPI.h>
#include <XPT2046_Touchscreen.h>
#include <TFT_eSPI.h>
#include <SD.h>
#include <IRremote.h>
#include <Adafruit_NeoPixel.h>
#include <WiFi.h>


#define IR_RECEIVER_PIN 22       // IR sensor connected to digital pin 2
#define NEOPIXEL_PIN 27          // NeoPixel data pin
#define NUM_IND 24            // Number of NeoPixels

Adafruit_NeoPixel WORK_IND(NUM_IND, NEOPIXEL_PIN, NEO_GRB + NEO_KHZ800);


#define XPT2046_IRQ 36
#define XPT2046_MOSI 32
#define XPT2046_MISO 39
#define XPT2046_CLK 25
#define XPT2046_CS 33

#define DEBOUNCE_DELAY 100  // Debounce delay for touch input

unsigned long lastTouchTime = 0;
unsigned long lastRTCUpdate = 0;
String rtcTime = "--:--";  // Default if no RTC data is detected
static String previousTime = ""; // Track previous time to reduce flicker


// UART setup for ESP32 communication
#define RX_PIN 3
#define TX_PIN 1

String incomingData;

#define GREEN_LED 16  // Turns ON at startup for confirmation
#define BLUE_LED  17  // Blinks ON when touched
#define RED_LED  4  // Blinks ON when touched

#define ESP32_MAIN Serial1   // For talking to serial ESP32 MAIN
#define DEBUG       Serial  // For serial monitor/PC debugging

SPIClass mySpi = SPIClass(VSPI);
XPT2046_Touchscreen ts(XPT2046_CS, XPT2046_IRQ);
TFT_eSPI tft = TFT_eSPI();

const char* mainMenu[] = {"Show Menu", "Settings", "Diagnostics"};
const int menuLength = sizeof(mainMenu) / sizeof(mainMenu[0]);
int selectedMenu = -1;



String wifiSSID = "";            // WiFi SSID entered via IR keyboard
String wifiPassword = "";       // WiFi password entered via IR keyboard


// Add "WiFi Configuration" to the Settings Menu
const char* settingsMenuOptions[] = {"Brightness Control", "WiFi Configuration"};
const int settingsMenuLength = sizeof(settingsMenuOptions) / sizeof(settingsMenuOptions[0]);




int menuSpacing = 30;
int firstMenuY = 50;
int backButtonY = 200;
bool inSubMenu = false;



const byte buttonCode[44] = {
  0x5C,0x5D,0x41,0x40,
  0x58,0x59,0x45,0x44,
  0x54,0x55,0x49,0x48,
  0x50,0x51,0x4D,0x4C,
  0x1C,0x1D,0x1E,0x1F,
  0x18,0x19,0x1A,0x1B,
  0x14,0x15,0x16,0x17,
  0x10,0x11,0x12,0x13,
  0xC,0xD,0xE,0xF,
  0x8,0x9,0xA,0xB,
  0x4,0x5,0x6,0x7
};

const byte ASCIIcode[44] = {
  0x31,0x32,0x33,0x34,
  0x35,0x36,0x37,0x38,
  0x39,0x30,0x2A,0x23,
  0x41,0x42,0x43,0x44,
  0x45,0x46,0x47,0x48,
  0x49,0x4A,0x4B,0x4C,
  0x4D,0x4E,0x4F,0x50,
  0x51,0x52,0x53,0x54,
  0x55,0x56,0x57,0x58,
  0x59,0x5A,0xFA,0xFB,
  0xFC,0xFD,0xFE,0xFF
};

#define SHIFT_KEY 0xA1  // Example Shift key code
#define ENTER_KEY 0xA2  // Example Enter key code
#define UP_ARROW 0xA3
#define DOWN_ARROW 0xA4
#define LEFT_ARROW 0xA5
#define RIGHT_ARROW 0xA6

IRrecv irrecv(IR_RECEIVER_PIN);
decode_results results;

bool shiftActive = false;



// Track Bluetooth State
bool bluetoothEnabled = false;
#define DEBOUNCE_DELAY 300  

// ** Brightness Stages (1-5) **
int brightnessLevel = 3;  // Default brightness stage (1-5)
// ** Map Stage Values to Actual Brightness Values **
int brightnessValues[5] = {50, 100, 150, 200, 255};

// ** Function Declarations **
void drawMenu();
void drawCenteredText(const char* text, int y, int textSize = 2);
void drawBackButton();
void displayTimeOnTouchscreen(String timestamp);


void showMenu() {
    tft.fillScreen(TFT_BLACK);
    drawCenteredText("Show Menu", 30, 2);
    drawCenteredText("Feature Coming Soon", 180, 2);
    drawBackButton();
}

void settingsMenu();
void diagnosticsMenu();
void showLoadingScreen();
void handleMenuSelection(int selectedMenu);

// ** Draw Centered Text **
void drawCenteredText(const char* text, int y, int textSize) {
    int charWidth = 6;
    int textWidth = strlen(text) * charWidth * textSize;
    int x = (tft.width() - textWidth) / 2;

    tft.setTextSize(textSize);
    tft.setCursor(x, y);
    tft.print(text);
}

// ** Display Time on Touchscreen **
void displayTimeOnTouchscreen(String timestamp) {
    if (ESP32_MAIN.available()) {
        String receivedData = ESP32_MAIN.readStringUntil('\n');
        receivedData.trim();

        if (receivedData.startsWith("TIME:")) {
            rtcTime = receivedData.substring(5);  // Extract time from data
        }
    }

    if (rtcTime != previousTime) { // Only update if the time has changed
        tft.setTextSize(2);
        tft.setTextColor(TFT_WHITE, TFT_BLACK); // White text, black background
        tft.setCursor(5, 5);                    // Top-left position (x=5, y=5)
        tft.fillRect(5, 5, 100, 20, TFT_BLACK); // Clear previous time digits only
        tft.print(rtcTime);                     // Display the RTC time
        previousTime = rtcTime;                 // Update the previous time
    }
}

// ** Show Loading Screen **
void showLoadingScreen() {
    tft.fillScreen(TFT_BLACK);
    tft.setTextColor(TFT_WHITE);
    tft.setTextSize(3);
    drawCenteredText("SHOWDUINO", 40, 3);

    tft.setTextSize(2);
    drawCenteredText("SYSTEM v1.0", 70, 2);

    for (int progress = 0; progress <= 100; progress += 10) {
        delay(300);
    }
}


void handleIRInput(uint16_t command) {
    for (int i = 0; i < 44; i++) {
        if (command == buttonCode[i]) {
            Serial.print("Key Pressed: ");
            Serial.write(ASCIIcode[i]);
            Serial.println();
            showFeedback(true);
            return;
        }
    }

    if (command == SHIFT_KEY) {
        shiftActive = !shiftActive;
        Serial.println(shiftActive ? "Shift Activated" : "Shift Deactivated");
        showFeedback(true);
    } 
    else if (command == ENTER_KEY) {
        Serial.println("Enter Key Pressed");
        showFeedback(true);
    } 
    else if (command == UP_ARROW) {
        Serial.println("Arrow Up");
        showFeedback(true);
    } 
    else if (command == DOWN_ARROW) {
        Serial.println("Arrow Down");
        showFeedback(true);
    } 
    else if (command == LEFT_ARROW) {
        Serial.println("Arrow Left");
        showFeedback(true);
    } 
    else if (command == RIGHT_ARROW) {
        Serial.println("Arrow Right");
        showFeedback(true);
    } 
    else {
        Serial.println("Unrecognized Command");
        showFeedback(false);
    }
}

void showFeedback(bool success) {
    WORK_IND.clear();
    if (success) {
        for (int i = 0; i < NUM_IND; i++) {
            WORK_IND.setPixelColor(i, WORK_IND.Color(0, 255, 0));  // Green for recognized input
        }
    } else {
        for (int i = 0; i < NUM_IND; i++) {
            WORK_IND.setPixelColor(i, WORK_IND.Color(255, 0, 0));  // Red for unrecognized input
        }
    }
    WORK_IND.show();
    delay(300);
    WORK_IND.clear();
    WORK_IND.show();
}

// ** Original Menu System **
void drawMenu() {
    inSubMenu = false;
    tft.fillScreen(TFT_BLACK);
    tft.fillRect(0, 10, tft.width(), 20, TFT_BLACK);  // Clear old text artifacts
    drawCenteredText("Main Menu", 10, 2);
    tft.setTextColor(TFT_WHITE, TFT_BLACK);
    tft.setTextSize(2);

    for (int i = 0; i < menuLength; i++) {
        int yPosition = firstMenuY + (i * menuSpacing);
        drawCenteredText(mainMenu[i], yPosition, 2);
    }
}

// ** Settings Menu **
void settingsMenu() {
    delay(300);  // Added delay to prevent instant menu selection
    tft.fillScreen(TFT_BLACK);
    drawCenteredText("Settings Menu", 30, 2);

    for (int i = 0; i < settingsMenuLength; i++) {
        int yPosition = firstMenuY + (i * menuSpacing);
        drawCenteredText(settingsMenuOptions[i], yPosition, 2);
    }

    drawBackButton();

    while (true) {
        if (ts.tirqTouched() && ts.touched()) {
            TS_Point p = ts.getPoint();
            int touchY = map(p.y, 0, 4095, 0, tft.height());

            if (touchY >= firstMenuY && touchY <= firstMenuY + (settingsMenuLength * menuSpacing)) {
                int touchedItem = (touchY - firstMenuY) / menuSpacing;
                switch (touchedItem) {
                    case 0:
                        brightnessMenu();
                        return;
                    case 1:
                        wifiConfigMenu();
                        return;
                    default:
                        break;
                }
            }

            if (touchY >= backButtonY - 20 && touchY <= backButtonY + 30) {
                drawMenu();
                inSubMenu = false;
                delay(200);  // Debounce
                return;
            }
        }
        delay(100);
    }
}

void connectToWiFi(const char* ssid) {
    tft.fillScreen(TFT_BLACK);
    drawCenteredText("Connecting...", 100, 2);

    WiFi.begin(ssid, wifiPassword.c_str());

    unsigned long startTime = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - startTime < 10000) { // 10 seconds timeout
        delay(500);
    }

    if (WiFi.status() == WL_CONNECTED) {
        drawCenteredText("Connected Successfully!", 120, 2);
    } else {
        drawCenteredText("Connection Failed!", 120, 2);
    }

    delay(2000);
    wifiScanMenu();
}
// ** WiFi Scan Menu **
void wifiScanMenu() {
    int selectedNetwork = -1;
    const int MAX_ITEMS_PER_PAGE = 4;
    int currentPage = 0;

    while (true) {
        tft.fillScreen(TFT_BLACK);
        drawCenteredText("WiFi Networks", 30, 2);

        int numNetworks = WiFi.scanNetworks();
        if (numNetworks == 0) {
            drawCenteredText("No Networks Found", 80, 2);
            delay(2000);
            settingsMenu();
            return;
        }

        int startIdx = currentPage * MAX_ITEMS_PER_PAGE;
        int endIdx = min(startIdx + MAX_ITEMS_PER_PAGE, numNetworks);

        for (int i = startIdx; i < endIdx; i++) {
            if (i == selectedNetwork) {
                tft.setTextColor(TFT_YELLOW, TFT_BLACK);  // Highlight selected network
            } else {
                tft.setTextColor(TFT_WHITE, TFT_BLACK);  // Normal text
            }
            int yPosition = firstMenuY + ((i - startIdx) * menuSpacing);
            drawCenteredText(WiFi.SSID(i).c_str(), yPosition, 2);
        }

        drawCenteredText("< Prev     Next >", backButtonY, 2);
        drawBackButton();

        if (ts.tirqTouched() && ts.touched()) {
            TS_Point p = ts.getPoint();
            int touchY = map(p.y, 0, 4095, 0, tft.height());

            for (int i = startIdx; i < endIdx; i++) {
                int yPosition = firstMenuY + ((i - startIdx) * menuSpacing);
                if (touchY >= yPosition && touchY <= yPosition + menuSpacing) {
                    selectedNetwork = i;  // Store selected network index
                }
            }

            if (touchY >= backButtonY - 20 && touchY <= backButtonY + 30) {
                if (selectedNetwork != -1) {
                    connectToWiFi(WiFi.SSID(selectedNetwork).c_str());
                    return;
                }
                settingsMenu();
                return;
            }
        }
        delay(100);
    }
}

// Future Menus can now follow this pattern using `genericMenu()`


// Future Menus can now follow this pattern using `genericMenu()`

// ** Brightness Control Submenu **
void brightnessMenu() {
    tft.fillScreen(TFT_BLACK);
    drawCenteredText("Brightness Control", 30, 2);

    drawCenteredText(("Current: Stage " + String(brightnessLevel)).c_str(), 100, 2);
    drawCenteredText("Tap to Increase", 140, 2);
    drawBackButton();

    while (true) {
        if (ts.tirqTouched() && ts.touched()) {
            TS_Point p = ts.getPoint();
            int touchY = map(p.y, 0, 4095, 0, tft.height());

            if (touchY >= 140 && touchY <= 180) {
                brightnessLevel++;
                if (brightnessLevel > 5) brightnessLevel = 1;  // Loop back to Stage 1

                analogWrite(TFT_BL, brightnessValues[brightnessLevel - 1]);

                tft.fillRect(0, 100, tft.width(), 20, TFT_BLACK);  // Clear old brightness text
                drawCenteredText(("Current: Stage " + String(brightnessLevel)).c_str(), 100, 2);
            }

            if (touchY >= backButtonY - 20 && touchY <= backButtonY + 30) {
                settingsMenu();
                return;
            }
        }
        delay(100);
    }
}

void diagnosticsMenu() {
    tft.fillScreen(TFT_BLACK);
    drawCenteredText("Diagnostics Menu", 30, 2);
    ESP32_MAIN.println("REQUEST_DIAGNOSTICS");  // Forwarded to Mega
    drawBackButton();
}

void handleMenuSelection(int selectedMenu) {
    inSubMenu = true;
    switch (selectedMenu) {
        case 0:
            showMenu();
            break;
        case 1:
            settingsMenu();
            break;
        case 2:
            diagnosticsMenu();
            break;
        default:
            break;
    }
}

void drawBackButton() {
    drawCenteredText("Back", backButtonY, 2);
}



// WiFi Scan Function
void scanWiFiNetworks() {
    tft.fillScreen(TFT_BLACK);
    drawCenteredText("Scanning for Networks...", 30, 2);
    int numNetworks = WiFi.scanNetworks();

    if (numNetworks == 0) {
        drawCenteredText("No Networks Found", 80, 2);
        delay(2000);
        settingsMenu();
        return;
    }

    for (int i = 0; i < numNetworks; i++) {
        drawCenteredText(WiFi.SSID(i).c_str(), 80 + (i * 20), 2);
    }

    drawCenteredText("Select Network with IR", 200, 2);
}

// IR Keyboard Handling for Text Entry
void wifiConfigMenu() {
    scanWiFiNetworks();
    wifiSSID = "";
    wifiPassword = ""; // Clear previous input

    while (true) {
        if (irrecv.decode(&results)) {
            if (results.value == ENTER_KEY) {
                tft.fillScreen(TFT_BLACK);
                drawCenteredText("Connecting...", 100, 2);
                connectToWiFi();
                delay(2000);
                settingsMenu();
                return;
            } else {
                char character = mapIRCodeToCharacter(results.value);
                if (character != 0) {
                    wifiPassword += character;
                    tft.fillRect(0, 100, tft.width(), 20, TFT_BLACK); // Clear old password text
                    drawCenteredText(wifiPassword.c_str(), 100, 2);
                }
            }
            irrecv.resume();
        }

        if (ts.tirqTouched() && ts.touched()) {
            TS_Point p = ts.getPoint();
            int touchY = map(p.y, 0, 4095, 0, tft.height());

            if (touchY >= backButtonY - 20 && touchY <= backButtonY + 30) {
                settingsMenu();
                return;
            }
        }
        delay(100);
    }
}

// Map IR codes to characters for password entry
char mapIRCodeToCharacter(uint16_t command) {
    for (int i = 0; i < 44; i++) {
        if (command == buttonCode[i]) {
            return ASCIIcode[i];
        }
    }
    return 0;  // Return 0 if no match
}

// WiFi Connection Function
void connectToWiFi() {
    WiFi.begin(wifiSSID.c_str(), wifiPassword.c_str());

    unsigned long startTime = millis();
    while (WiFi.status() != WL_CONNECTED && millis() - startTime < 10000) { // 10 seconds timeout
        delay(500);
    }

    if (WiFi.status() == WL_CONNECTED) {
        drawCenteredText("Connected Successfully!", 120, 2);
    } else {
        drawCenteredText("Connection Failed!", 120, 2);
    }
}




void setup() {
    DEBUG.begin(115200);  
       Serial2.begin(115200, SERIAL_8N1, 27, 26);  // ESP32 TX (26) → Mega RX1 (19), ESP32 RX (27) ← Mega TX1 (18)

    delay(1000);  
    DEBUG.println("[DEBUG] ESP32 Boot Successful!");
     irrecv.enableIRIn(); // Start the IR receiver
    tft.init();
    tft.setRotation(3);
    showLoadingScreen();
   
    mySpi.begin(XPT2046_CLK, XPT2046_MISO, XPT2046_MOSI, XPT2046_CS);
    ts.begin(mySpi);
    ts.setRotation(3);
    ESP32_MAIN.begin(115200, SERIAL_8N1, RX_PIN, TX_PIN);  // UART communication with Mega
     drawMenu();
}

void loop() {
     displayTimeOnTouchscreen(rtcTime);




    if (irrecv.decode(&results)) {
        handleIRInput(results.value);
        irrecv.resume();
    }
 
    if (ts.tirqTouched() && ts.touched()) {
        TS_Point p = ts.getPoint();
        int touchY = map(p.y, 0, 4095, 0, tft.height());

        if (!inSubMenu) {
            if (touchY >= firstMenuY && touchY <= firstMenuY + (menuLength * menuSpacing)) {
                int touchedItem = floor((touchY - firstMenuY) / (float)menuSpacing);
                touchedItem = constrain(touchedItem, 0, menuLength - 1);
                selectedMenu = touchedItem;
                handleMenuSelection(selectedMenu);
            }
        } else {
            if (touchY >= backButtonY - 20 && touchY <= backButtonY + 20) {
                drawMenu();
                inSubMenu = false;
            }
        }
    }
}
